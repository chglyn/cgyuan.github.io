<!doctype html>




<html lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">









  <meta name="baidu-site-verification" content="Wh9e8U7wdZ">







  
  
    
  
  <link href="//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css">







  


<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.2/css/font-awesome.min.css" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="园子,web前端技术栈,web技术栈,Vue.js实战,微信小程序,React Native,Webpack,MVVM,React.js,Node.js,Redux,JavaScript,vue-router,react-router,小程序,跨端开发,react hooks,redux-saga,Web 前端实战,小程序实战,移动端实战,yuan blog">


<meta property="article:tag" content="Vue.js实战">
<meta property="article:tag" content="微信小程序">
<meta property="article:tag" content="React Native">
<meta property="article:tag" content="Webpack">
<meta property="article:tag" content="MVVM">
<meta property="article:tag" content="React.js">
<meta property="article:tag" content="Node.js">
<meta property="article:tag" content="Redux">
<meta property="article:tag" content="JavaScript">
<meta property="article:tag" content="react hooks">
<meta property="article:tag" content="redux-saga">
<meta property="article:tag" content="Web 前端">
<meta property="article:tag" content="移动端实战">
<meta property="article:tag" content="小程序实战">



  <link rel="alternate" href="/atom.xml" title="园子" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/bitbug_favicon.ico?v=5.1.0">






<meta name="description" content="前言 浅入JS基础。本篇从工作、学习总结归纳JavaScript，列举以下技巧。  文章涉及： 变量声明 typeof 数据类型 理解函数 全局对象(GO) 闭包 作用域 作用域链 立即执行函数与函数表达式 运算符 对象 new关键字 包装类 原型 原型链 Object.create() call apply 继承 命名空间 链式调用 对象枚举 this 数组 类数组 try catch  var">
<meta property="og:type" content="article">
<meta property="og:title" content="学习JavaScript基础篇">
<meta property="og:url" content="http://blog.yuanbeauty.com/archives/3a1eeae5.html">
<meta property="og:site_name" content="园子">
<meta property="og:description" content="前言 浅入JS基础。本篇从工作、学习总结归纳JavaScript，列举以下技巧。  文章涉及： 变量声明 typeof 数据类型 理解函数 全局对象(GO) 闭包 作用域 作用域链 立即执行函数与函数表达式 运算符 对象 new关键字 包装类 原型 原型链 Object.create() call apply 继承 命名空间 链式调用 对象枚举 this 数组 类数组 try catch  var">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://blog.yuanbeauty.com/images/1_1.png">
<meta property="og:updated_time" content="2015-08-09T16:00:00.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="学习JavaScript基础篇">
<meta name="twitter:description" content="前言 浅入JS基础。本篇从工作、学习总结归纳JavaScript，列举以下技巧。  文章涉及： 变量声明 typeof 数据类型 理解函数 全局对象(GO) 闭包 作用域 作用域链 立即执行函数与函数表达式 运算符 对象 new关键字 包装类 原型 原型链 Object.create() call apply 继承 命名空间 链式调用 对象枚举 this 数组 类数组 try catch  var">
<meta name="twitter:image" content="http://blog.yuanbeauty.com/images/1_1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":true},
    fancybox: true,
    motion: false,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.yuanbeauty.com/archives/3a1eeae5.html">





  <title> 学习JavaScript基础篇 - 园子 - 或许为了自身写，或许为了知己写！ </title>
</head>

<body lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>
    <a href="/" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a>
    
    <header id="header" class="header page-post-detail">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">园子</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">或许为了自身写，或许为了知己写！</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      

        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页  
            
            
            
          </a>
        </li>
      

        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档  
            
            
              <span class="menu-num">24</span>
            
            
          </a>
        </li>
      

        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类  
            
            
              <span class="menu-num">29</span>
            
            
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.yuanbeauty.com/archives/3a1eeae5.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Changyuan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/cc-bf-chglyn.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="园子">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                学习JavaScript基础篇
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-08-10T00:00:00+08:00">
                2015-08-10
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2015-08-10T00:00:00+08:00">
                2015-08-10
              </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a class="cloud-tie-join-count" href="/archives/3a1eeae5.html#comments" itemprop="discussionUrl">
                  <span class="post-comments-count join-count" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                  
                    <span class="post-meta-item-text">字数统计</span>
                  
                    <span title="字数统计" }}">
                      6.8k 字
                    </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>前言</p>
<p>浅入JS基础。本篇从工作、学习总结归纳JavaScript，列举以下技巧。</p>
<ul>
<li>文章涉及：</li>
<li>变量声明</li>
<li>typeof</li>
<li>数据类型</li>
<li>理解函数</li>
<li>全局对象(GO)</li>
<li>闭包</li>
<li>作用域</li>
<li>作用域链</li>
<li>立即执行函数与函数表达式</li>
<li>运算符</li>
<li>对象</li>
<li>new关键字</li>
<li>包装类</li>
<li>原型</li>
<li>原型链</li>
<li>Object.create()</li>
<li>call</li>
<li>apply</li>
<li>继承</li>
<li>命名空间</li>
<li>链式调用</li>
<li>对象枚举</li>
<li>this</li>
<li>数组</li>
<li>类数组</li>
<li>try catch</li>
</ul>
<h3 id="var"><a href="#var" class="headerlink" title="var"></a>var</h3><ul>
<li>即任何变量，如果未经声明就使用，此变量就为全局变量所拥有。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 没有使用var，在全局声明变量num，变量num属于window</span><br><span class="line">num = 10;</span><br><span class="line">console.log(window.num) // 10</span><br></pre></td></tr></table></figure>
<ul>
<li>一切声明的全局变量，全是window的属性。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 使用var在全局声明变量num，变量num就属于window。</span><br><span class="line">var num = 10; </span><br><span class="line">console.log(window.num) // 10</span><br></pre></td></tr></table></figure>
<p>注意</p>
<p>一旦经历var操作，所得出的属性属于window，这种属性叫做不可配置属性，<strong>不可配置属性不能delete</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var num = 1;</span><br><span class="line">delete window.num // false</span><br></pre></td></tr></table></figure>
<ul>
<li>全局定义相同变量，后面变量能把前面变量覆盖。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var num = 1; // 首次定义  </span><br><span class="line">...</span><br><span class="line">var num = 10; // 后面再次定义 </span><br><span class="line">console.log(num) // 10</span><br></pre></td></tr></table></figure>
<h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>返回数据类型字符串表达。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var num = 1;</span><br><span class="line">typeof num // &apos;number&apos; </span><br><span class="line"></span><br><span class="line">var x = &apos;app&apos;;</span><br><span class="line">typeof x // &apos;string&apos; </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>typeof 存在比较特殊地方。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">typeof null // &apos;object&apos; </span><br><span class="line">typeof Array // &apos;object&apos;</span><br></pre></td></tr></table></figure>
<p>通过typeof能返回：number/string/boolean/object/function类型。</p>
<p>能判断：undefined/number/boolean/function</p>
<p>不能判断： null/object/Array。</p>
<p>对于NaN，返回number，NaN是not a number的缩写。</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>包括基本数据类型与引用数据类型。</p>
<p>基本数据类型（栈stack） 包括：number/string/boolean/null/undefined。基本数据类型访问顺序按值访问，由高向低分配，占内存最大是8MB，其中string是特殊的栈，由程序员分配。</p>
<p>引用类型(堆heap) 包括：function/object/Array。引用类型在栈内存中保存的是对象在堆内存中的引用地址(指针)，向高分配，系统自由分配。</p>
<ul>
<li>空间分配方式：<br>栈：由操作系统自由分配释放。<br>堆：一般由程序员分配释放。</li>
</ul>
<ul>
<li>数据结构：<br>栈：先进后出的模式。<br>堆：可以看成一颗树。</li>
</ul>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>预编译发生在函数执行前一刻。<br>预编译过程：</p>
<ul>
<li>创建AO对象：Activetion Object</li>
<li>找形参和变量声明，将变量和形参名作为AO属性名，值为：undefined</li>
<li>将实参值和形参统一</li>
<li>在函数体里面找函数声明，值赋予函数体</li>
</ul>
<p>代码片段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function fn(x, y) &#123;</span><br><span class="line">  z = 3;</span><br><span class="line">  function bar() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">fn(1, 2);</span><br></pre></td></tr></table></figure></p>
<ul>
<li>首次创建Activetion Object<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x:         undefined</span><br><span class="line">y:         undefined</span><br><span class="line">z:         undefined</span><br><span class="line">bar:       undefined</span><br><span class="line">arguments: undefined</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>然后实参值与形参统一<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x:         1</span><br><span class="line">y:         2</span><br><span class="line">z:         3</span><br><span class="line">bar:       undefined</span><br><span class="line">arguments: &lt;1, 2&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>函数体中如果有函数声明，值赋予函数体<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x:         1</span><br><span class="line">y:         2</span><br><span class="line">z:         3</span><br><span class="line">bar:       &lt;function&gt;</span><br><span class="line">arguments: &lt;1, 2&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Global-Object-GO"><a href="#Global-Object-GO" class="headerlink" title="Global Object(GO)"></a>Global Object(GO)</h3><p>简称全局对象，与widow关系是全等(Global Object === window)。</p>
<p>代码片段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function a() &#123;</span><br><span class="line">  function b() &#123;</span><br><span class="line">    function c() &#123;&#125;</span><br><span class="line">    c();</span><br><span class="line">  &#125;</span><br><span class="line">  b();</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure></p>
<p>通过上述代码片段，函数a在全局定义，同时创建自己的scope属性，指向它父函数作用域链Global Object；函数a执行，scope属性指向自身Activetion Object；通过全局Global Object返回，拿到函数a结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">a   defined a.[[scope]] --&gt; 0: GO</span><br><span class="line"></span><br><span class="line">a   doing   a.[[scope]] --&gt; 0: a AO</span><br><span class="line">                        --&gt; 1: GO</span><br></pre></td></tr></table></figure></p>
<p>函数b定义，是在函数a执行结果上定义，同时创建自己的scope；函数b执行，scope属性指向自身Activetion Object，经过函数a的Activetion Object，传递给全局Global Object返回，拿到函数b结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// ...省略函数a </span><br><span class="line">b   defined b.[[scope]] --&gt; 0: aAO</span><br><span class="line">                        --&gt; 1: GO</span><br><span class="line"></span><br><span class="line">b   doing   b.[[scope]] --&gt; 0: bAO</span><br><span class="line">                        --&gt; 1: aAO</span><br><span class="line">                        --&gt; 2: GO</span><br></pre></td></tr></table></figure></p>
<p>函数c定义，是在函数b执行结果上定义，同时创建自己的scope；函数c执行，scope属性指向自身Activetion Object，经过函数b的Activetion Object，经过函数a的Activetion Object，通过全局Global Object返回，拿到函数c结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// ...省略函数a </span><br><span class="line">// ...省略函数b </span><br><span class="line">c   defined c.[[scope]] --&gt; 0: bAO</span><br><span class="line">                        --&gt; 1: aAO</span><br><span class="line">                        --&gt; 2: GO</span><br><span class="line"></span><br><span class="line">c   doing   c.[[scope]] --&gt; 0: cAO</span><br><span class="line">                        --&gt; 1: bAO</span><br><span class="line">                        --&gt; 2: aAO    </span><br><span class="line">                        --&gt; 3: GO</span><br></pre></td></tr></table></figure></p>
<p>通过上述分析可以看到，函数是定义在它父劳动成果上。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>内部的函数被保存到外部，将生成闭包。闭包会导致原作用域链不释放，造成内存泄露。通俗理解里面的函数比外面的函数活着还长。</p>
<p>规则：</p>
<ul>
<li>一定是嵌套函数</li>
<li>内层函数一定操作了外层函数的局部变量</li>
<li>外层函数一定将内层函数返回外部, 并且被全局变量保存</li>
</ul>
<p>代码片段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function fn() &#123;</span><br><span class="line">  function bar() &#123;</span><br><span class="line">    var y = 2;</span><br><span class="line">    console.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">  var x = 1;</span><br><span class="line">  return bar;</span><br><span class="line">&#125;</span><br><span class="line">var f = fn();</span><br><span class="line">f();</span><br></pre></td></tr></table></figure></p>
<p>闭包运用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function fn() &#123;</span><br><span class="line">  var arr = [];</span><br><span class="line">  for(var i=0; i&lt;10; i++) &#123;</span><br><span class="line">    arr[i] = function() &#123;</span><br><span class="line">      console.log(i) // 输出10次10 </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return arr;</span><br><span class="line">&#125;</span><br><span class="line">var myArr = fn();</span><br><span class="line">for(var j=0; j&lt;10; j++) &#123;</span><br><span class="line">  myArr[i]();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>打印输出10次10，是因为声明i变量是全局变量。<br>for语句可以这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(var i=0; i&lt;10; i++) &#123; </span><br><span class="line">  // ...  </span><br><span class="line">&#125;</span><br><span class="line">// 修改下面是等效 </span><br><span class="line">var i = 0;</span><br><span class="line">for(; i&lt;10; i++) &#123;</span><br><span class="line">  // ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于上面代码打印0-10，可通过闭包修改，设置局部变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function fn() &#123;</span><br><span class="line">var arr = [];</span><br><span class="line">for(var i=0; i&lt;10; i++) &#123;</span><br><span class="line">    (function(j) &#123; // 形参 </span><br><span class="line">       arr[j] = function() &#123;</span><br><span class="line">          console.log(j) // 输出0-10</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(i)</span><br><span class="line">  &#125;</span><br><span class="line">return arr;</span><br><span class="line">&#125;</span><br><span class="line">var myArr = fn();</span><br><span class="line">for(var j=0; j&lt;10; j++) &#123;</span><br><span class="line">  myArr[i]();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>ES5中提出全局作用域和函数作用域。</p>
<p>全局作用域忘记，可以往上翻翻开篇提到的部分；这里补充函数作用域，函数作用域是在函数内部的变量。</p>
<p>代码片段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function fn() &#123;</span><br><span class="line">  var num = 10;</span><br><span class="line">  console.log(num); // 10 </span><br><span class="line">  function bar() &#123;</span><br><span class="line">    console.log(num) // 10 </span><br><span class="line">  &#125;</span><br><span class="line">  bar();</span><br><span class="line">&#125;</span><br><span class="line">console.log(num) // 抛出 error </span><br><span class="line">fn();</span><br></pre></td></tr></table></figure></p>
<p>通过上述结果可以理解，<strong>函数会创建自己的作用域’{}’，并且作用域分层，函数内层域能访问函数外层域，反之不行</strong>。<br>值得注意的是<strong>在if/for/switch/while语句后面的“{}”，不会创建自己的作用域</strong>，定义的变量保存在已经定义的作用域中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(true) &#123;</span><br><span class="line">  var num = 10;</span><br><span class="line">&#125;</span><br><span class="line">console.log(num) // 10</span><br></pre></td></tr></table></figure></p>
<p>变量num虽然在’{ }’中，但是if不会创建自己的作用域，变量num相当于定义在全局。</p>
<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>链可以理解为一层一层的向上寻找。在作用域中呢？<br>看看相关代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var num = 10;</span><br><span class="line">function  fn() &#123;</span><br><span class="line">  console.log(num);</span><br><span class="line">&#125;</span><br><span class="line">fn(); // 输出结果 10</span><br></pre></td></tr></table></figure></p>
<p>函数fn创建自己的域，在函数内层域中寻找变量num，发现当前域没有定义变量num，继续向函数外层域寻找变量，最后在外层域中找到变量num，输出10。</p>
<p>目前说明<strong>作用域链是一层一层向上寻找，直到找到所需变量或者最顶层也没找到就停止寻找并返回结果</strong>。</p>
<p>那么能不能理解成一层一层向函数父域中寻找呢？看下面相关代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var num = 10;</span><br><span class="line">function fn() &#123;</span><br><span class="line">  console.log(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function bar() &#123;</span><br><span class="line">  var num = 20;</span><br><span class="line">  (function() &#123;</span><br><span class="line">    fn();</span><br><span class="line">  &#125;)()</span><br><span class="line">&#125;</span><br><span class="line">bar(); // 输出结果10</span><br></pre></td></tr></table></figure></p>
<p>上述代码输出结果10。通过这个可以分析<strong>函数会在创建函数的这个域中寻找值，不是调用这个函数域</strong>，说向父域中不准确。</p>
<h3 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h3><p>可以理解成执行完就释放。<br>代码片段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(function(x, y) &#123; // x, y是形参 </span><br><span class="line">  console.log(x + y);</span><br><span class="line">&#125;)(1, 2) // 1, 2 是实参</span><br></pre></td></tr></table></figure></p>
<p>可以定义一个变量接收。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var num = (function(x, y) &#123;</span><br><span class="line">  var z = x + y;</span><br><span class="line">  return z;</span><br><span class="line">&#125;)(1, 2)</span><br><span class="line"></span><br><span class="line">console.log(num)  // 3</span><br></pre></td></tr></table></figure></p>
<p>注意：<strong>只有表达式才能被执行符号“( )”执行</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var fn = function() &#123;</span><br><span class="line">  console.log(&apos;hello&apos;);</span><br><span class="line">&#125;()</span><br><span class="line">// 首次调用输出 hello  </span><br><span class="line">// 再次调用console.log(fn) 输出 undefined</span><br></pre></td></tr></table></figure></p>
<p>函数调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function fn() &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure></p>
<p>函数使用call方法调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">foo.call();</span><br></pre></td></tr></table></figure></p>
<p>这两个函数打印值是相等。</p>
<p>函数后面添加运算符”( )”，调用函数什么也不输出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function fn(x, y) &#123;</span><br><span class="line">  console.log(x, y); // 无输出  </span><br><span class="line">&#125;(1, 2)</span><br></pre></td></tr></table></figure></p>
<p>函数前面支持正负非符号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+|-|! function fn() &#123;</span><br><span class="line">  console.log(&apos;hello&apos;); // hello  </span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure></p>
<p><strong>“( )”运算符。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var num = (1 - 1, 1 + 1); </span><br><span class="line">console.log(num) // 2 计算前面结果，再计算后面运算结果，返回后面结果</span><br></pre></td></tr></table></figure></p>
<p>if语句有函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line">if(function() &#123;&#125;) &#123;</span><br><span class="line">  x += typeof f;</span><br><span class="line">&#125;</span><br><span class="line">console.log(x) // 1undefined 此时函数转成表达式，在执行</span><br></pre></td></tr></table></figure></p>
<h3 id="对象模型"><a href="#对象模型" class="headerlink" title="对象模型"></a>对象模型</h3><p>由属性和属性对应值组成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line"> // 属性：值  </span><br><span class="line">  name: &apos;sunny&apos;,</span><br><span class="line">  age: 18,</span><br><span class="line">  say: function() &#123;</span><br><span class="line">    console.log(&apos;hello&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以操作对象：</p>
<ul>
<li>访问属性：obj.name</li>
<li>删除属性：delete obj.age</li>
<li>修改属性：obj.age = 28</li>
<li>添加属性：obj.sex = ‘male’</li>
</ul>
<p><strong>创建对象</strong></p>
<ul>
<li><p>使用字面量创建对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var  obj = &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用系统自带的构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var obj = new Object()</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;&#125;</span><br><span class="line">var person = new Person();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>注意：<br>构造函数和普通函数结构上没区别，存在new才会返回一个对象。<br>构造函数命名规则，大驼峰命名</p>
<h3 id="new关键字"><a href="#new关键字" class="headerlink" title="new关键字"></a>new关键字</h3><p>在构造函数前面添加new关键字，执行以下操作：</p>
<ul>
<li>在函数体最前面隐式的加上this = { }</li>
<li>执行 this.xxx = xxx</li>
<li>隐式的返回 this<br>相关代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Student(name, age) &#123;</span><br><span class="line">  // 隐式添加 this = &#123; </span><br><span class="line">  // name: name, </span><br><span class="line">  // ... </span><br><span class="line">  // &#125; </span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">  this.sex = &apos;male&apos;;</span><br><span class="line">  // 隐式添加 return this </span><br><span class="line">&#125;</span><br><span class="line">var student = new Student(&apos;sunny&apos;, 18);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>构造函数显示return空对象或者原始值；输出的结果不一样。</p>
<p>return对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Student(name, age) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">  this.sex = &apos;male&apos;;</span><br><span class="line">  return &#123;&#125;; // 返回一个空对象 </span><br><span class="line">&#125;</span><br><span class="line">var student = new Student(&apos;sunny&apos;, 18);</span><br><span class="line">console.log(student) // &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>return原始值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Student(name, age) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">  this.sex = &apos;male&apos;;</span><br><span class="line">  // 或者return 原始值; 相当于return this，返回一个对象 </span><br><span class="line">  return 123; </span><br><span class="line">&#125;</span><br><span class="line">var student = new Student(&apos;sunny&apos;, 18);</span><br><span class="line">console.log(student) // &#123;name: &quot;sunny&quot;, age: 18, sex: &quot;male&quot;&#125;</span><br></pre></td></tr></table></figure></p>
<p>自定义对象好处<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Car(color) &#123; // color参数 </span><br><span class="line">    this.color = color;  // color 接受参数</span><br><span class="line">    this.health = 100;</span><br><span class="line">    this.run = function() &#123;</span><br><span class="line">      this.health --;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">// car变量写成Car走预编译环节，进行覆盖</span><br><span class="line">var car1 = new Car(&apos;red&apos;); // &#123;color: &quot;red&quot;, health: 100, run: ƒ&#125;</span><br><span class="line">var car2 = new Car(&apos;green&apos;);// &#123;color: &quot;green&quot;, health: 100, run: ƒ&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过上述代码结果可以看出car1与car2属性相互各自独立互不影响。</p>
<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><p>原始值没有属性和方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// eg </span><br><span class="line">var num = 1;</span><br><span class="line">var num = new Number(num);</span><br><span class="line">num.a = &apos;a&apos;;</span><br><span class="line">console.log(num) // Number &#123;1, a: &quot;a&quot;&#125; </span><br><span class="line">console.log(num * 2) // 2 能计算，又返回原类型</span><br></pre></td></tr></table></figure></p>
<p>String添加属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;a&apos;;</span><br><span class="line">var str = new String(str);</span><br><span class="line">str.a = &apos;a&apos;;</span><br><span class="line">console.log(str.a) // a</span><br></pre></td></tr></table></figure></p>
<p>Number添加属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// eg: </span><br><span class="line">var num = 4;</span><br><span class="line">num.len = 3;</span><br><span class="line">console.log(num.len) // undefined</span><br></pre></td></tr></table></figure></p>
<p>执行过程:</p>
<ul>
<li>执行num.len时，发生new Number(num).len = 3新建一个数字对象，该对象len赋值为3，然后delete销毁。</li>
<li>再次访问重新创建数字对象，添加一个len属性，与上一步new Number不同。</li>
<li>输出结果undefined。</li>
</ul>
<p>boolean添加new。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var bol = new Boolean(&apos;true&apos;);</span><br><span class="line"></span><br><span class="line">// eg </span><br><span class="line">var str = &apos;abc&apos;;</span><br><span class="line">str +=1;</span><br><span class="line">var test = typeof str;</span><br><span class="line">if(test.length == 6) &#123;</span><br><span class="line">  test.sign = &apos;typdof返回的结果可能是string&apos;;</span><br><span class="line">&#125;</span><br><span class="line">console.log(test.sign);</span><br></pre></td></tr></table></figure></p>
<p>在if里面创建 new String(‘test’).sign = ‘typdof返回的结果可能是string’。<br>在最外层再次访问，重新创建new String(‘test’).sign。<br>最终输出结果 undefined。</p>
<p>解析片段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;abc&apos;;</span><br><span class="line">str +=1;</span><br><span class="line">var test = typeof str;</span><br><span class="line">if(test.length == 6) &#123;</span><br><span class="line">// 创建new String(&apos;test&apos;).sign = &apos;typdof返回的结果可能是string&apos; </span><br><span class="line">  test.sign = &apos;typdof返回的结果可能是string&apos;;</span><br><span class="line">&#125;</span><br><span class="line">// 再次访问重新创建new String(&apos;test&apos;).sign </span><br><span class="line">console.log(test.sign);</span><br></pre></td></tr></table></figure></p>
<p>注：undefined / null 没有String。</p>
<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>是function对象的一个属性，它定义了构造函数制造出的对象的公共祖先。通过该构造函数产生的对象，可以继承该原型的属性和方法，原型也是对象。</p>
<p>相关代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Person.prototype 看做原型 </span><br><span class="line">// Person.prototype = &#123;&#125; 看做祖先 </span><br><span class="line">Person.prototype.name = &apos;sunny&apos;;</span><br><span class="line">function Person() &#123;&#125;</span><br><span class="line">var p = new Person();</span><br><span class="line">// p.__proto__.constructor 指向 functon Person()&#123;&#125; </span><br><span class="line">// p.__proto__ === Person.prototype </span><br><span class="line">console.log(p.name) // sunny</span><br></pre></td></tr></table></figure></p>
<p>通过constructor更改指向。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;&#125;</span><br><span class="line">function Car() &#123;&#125;</span><br><span class="line">Car.prototype = &#123;</span><br><span class="line">   // constructor更改了指向 </span><br><span class="line">  constructor: Person;</span><br><span class="line">&#125;</span><br><span class="line">var car = new Car();</span><br></pre></td></tr></table></figure></p>
<p>new过程构造函数内部做了什么。</p>
<ul>
<li>内部隐式添加this对象；</li>
<li>改变this执向(指向原构造函数原型)；</li>
<li>返回一个新对象。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// eg </span><br><span class="line">Person.prototype.name = &apos;sunny&apos;;</span><br><span class="line">function Person() &#123;</span><br><span class="line">  // var this = &#123; </span><br><span class="line">  // __proto__: Person.prototype </span><br><span class="line">  // &#125; </span><br><span class="line">&#125;</span><br><span class="line">var person = new Person();</span><br><span class="line">var obj = &#123;</span><br><span class="line">  name: &apos;cherry&apos;</span><br><span class="line">&#125;</span><br><span class="line">person.__proto__  = obj;</span><br><span class="line">console.log(person.name) // cherry</span><br></pre></td></tr></table></figure>
<p>prototype在<strong>new前</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.name = &apos;sunny&apos;;</span><br><span class="line">function Person() &#123;&#125;</span><br><span class="line">Person.prototype.name = &apos;cherry&apos;;</span><br><span class="line">var p = new Person();</span><br><span class="line">console.log(p.name) // cherry</span><br></pre></td></tr></table></figure></p>
<p>通过上述代码看出<strong>prototype有提升作用，后面定义能把之前定义覆盖</strong>。</p>
<p>prototype在<strong>new后</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.name = &apos;sunny&apos;;</span><br><span class="line">function Person() &#123;&#125;</span><br><span class="line">var p = new Person();</span><br><span class="line">Person.prototype.name = &apos;cherry&apos;;</span><br><span class="line">console.log(p.name) // cherry</span><br></pre></td></tr></table></figure></p>
<p>可以看出<strong>prototype定义在new之后，值没有变化</strong>；prototype有提升作用，后面重新定义能把之前定义覆盖。</p>
<p><strong>prototype对象形式 写法</strong><br>在new前<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.name = &apos;sunny&apos;;</span><br><span class="line">function Person() &#123;&#125;</span><br><span class="line">Person.prototype = &#123; </span><br><span class="line">  name: &apos;cherry&apos;</span><br><span class="line">&#125;</span><br><span class="line">var p = new Person();</span><br><span class="line">console.log(p.name) // cherry</span><br></pre></td></tr></table></figure></p>
<p>通过上述看出Person原型给修改了，<strong>没有new生成就改变了</strong>。</p>
<p>在new之后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.name = &apos;sunny&apos;;</span><br><span class="line">function Person() &#123;&#125;</span><br><span class="line">var p = new Person();</span><br><span class="line">person.prototype = &#123; </span><br><span class="line">  name: &apos;cherry&apos;</span><br><span class="line">&#125;</span><br><span class="line">console.log(p.name) // sunny</span><br></pre></td></tr></table></figure></p>
<p>Person函数里面<strong>proto</strong>没有修改，只是在原基础上修改Person.prototype属性。</p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>Object.prototype是所有对象的最终原型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// eg </span><br><span class="line">Person.prototype.__proto__ = Object.prototype </span><br><span class="line">function Person() &#123;&#125; </span><br><span class="line">Person.prototype.name = &apos;sunny&apos;; </span><br><span class="line">var p = new Person()</span><br></pre></td></tr></table></figure></p>
<p>引用值可以自己操作自己 (原型链继承模式)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function Father() &#123; </span><br><span class="line">  this.name = &apos;sunny&apos;; </span><br><span class="line">  this.age = 46; </span><br><span class="line">&#125;</span><br><span class="line">var f = new Father(); </span><br><span class="line"></span><br><span class="line">Son.prototype = f; </span><br><span class="line">function Son() &#123;&#125; </span><br><span class="line">var s = new Son(); </span><br><span class="line">s.age++ </span><br><span class="line">console.log(f.age) // 46</span><br></pre></td></tr></table></figure></p>
<p>揭秘原型与原型链取值</p>
<p>相关代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype = &#123; </span><br><span class="line">  name: &apos;sunny&apos;, </span><br><span class="line">  say: function() &#123; </span><br><span class="line">    console.log(this.name) </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">function Person() &#123;&#125; </span><br><span class="line">var p = new Person(); </span><br><span class="line">console.log(p.say) // sunny</span><br></pre></td></tr></table></figure></p>
<p>修改上面代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype = &#123; </span><br><span class="line">  name: &apos;sunny&apos;, </span><br><span class="line">  say: function() &#123; </span><br><span class="line">    console.log(this.name) </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">function Person() &#123; </span><br><span class="line">  this.name = &apos;cherry&apos;; </span><br><span class="line">&#125;</span><br><span class="line">var p = new Person(); </span><br><span class="line">console.log(p.name) // cherry</span><br></pre></td></tr></table></figure></p>
<p>通过上述代码片段发现实例对象<strong>就近取值</strong>，如果没有找到值，沿着原型链继续往上寻找。</p>
<h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create"></a>Object.create</h3><p>语法：Object.create(原型)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; </span><br><span class="line">  name: &apos;sunny&apos; </span><br><span class="line">&#125;</span><br><span class="line">var obj1 = Object.create(obj);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.name = &apos;sunny&apos;; </span><br><span class="line">function Person() &#123;&#125; </span><br><span class="line">var p = Object.create(Person.prototype);</span><br></pre></td></tr></table></figure>
<p>绝大多数对象最终都会继承自Object.create，null除外。</p>
<h3 id="call-继承"><a href="#call-继承" class="headerlink" title="call (继承)"></a>call (继承)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age) &#123; </span><br><span class="line">  this.name = name; </span><br><span class="line">  this.age = age; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Son(name, age, sex) &#123; </span><br><span class="line">  Person.call(this, name, age); </span><br><span class="line">  this.sex = sex; </span><br><span class="line">&#125;</span><br><span class="line">var son = new Son(&apos;sunny&apos;, 18, &apos;male&apos;); </span><br><span class="line">console.log(son) // &#123;name: &quot;sunny&quot;, age: 18, sex: &quot;male&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码看出：能共用父类属性，支持传参。</p>
<h3 id="apply-继承"><a href="#apply-继承" class="headerlink" title="apply (继承)"></a>apply (继承)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123; </span><br><span class="line">  this.name = name; </span><br><span class="line">  this.age = age; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Son(name, age, sex) &#123; </span><br><span class="line">  Person.apply(this, [name, age]); </span><br><span class="line">  this.sex = sex; </span><br><span class="line">&#125;</span><br><span class="line">var son = new Son(&apos;sunny&apos;, 18, &apos;male&apos;)  </span><br><span class="line">console.log(son) // &#123;name: &quot;sunny&quot;, age: 18, sex:&quot;male&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码看出：能共用父类属性，支持传参，参数是数组形式。<br>对比可以总结归纳：<strong>call与apply传参序列不同，都能改变this指向</strong>。<br>call或者apply 参数为null/undefined时，执行JS全局对象浏览器中的window。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function fn() &#123; </span><br><span class="line">  foo.apply(null, arguments); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function foo() &#123; </span><br><span class="line">  console.log(arguments) </span><br><span class="line">&#125;</span><br><span class="line">foo(1, 2, 3) // 1, 2, 3</span><br></pre></td></tr></table></figure></p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul>
<li>原型链继承，结合子类原型与父类实例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 代码片段 </span><br><span class="line">Person.prototype.sleep = function() &#123;&#125; </span><br><span class="line">function Person(name, age) &#123; </span><br><span class="line">  this.name = name; </span><br><span class="line">  this.age = age; </span><br><span class="line">&#125;</span><br><span class="line">function Son(sex) &#123; </span><br><span class="line">  this.sex = sex; </span><br><span class="line">&#125;</span><br><span class="line">Son.prototype = new Person(); // 子类的原型为父类实例对象 </span><br><span class="line">var son = New Son(&apos;male&apos;); </span><br><span class="line">console.log(son)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/images/1_1.png" style="width:100%" alt="javascript"></p>
<p>如果在子类原型添加方法，能继承吗？ 修改代码：</p>
<p>在new Person之前：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.sleep = function() &#123;&#125; </span><br><span class="line">function Person(name, age) &#123; </span><br><span class="line">  this.name = name;  </span><br><span class="line">  this.age = age;  </span><br><span class="line">&#125;</span><br><span class="line">function Son(sex) &#123; </span><br><span class="line">  this.sex = sex;  </span><br><span class="line">&#125;  </span><br><span class="line">Son.prototype.eat = function() &#123;&#125; // 在这里... </span><br><span class="line">Son.prototype = new Person(); </span><br><span class="line">var son = new Son(&apos;male&apos;); </span><br><span class="line">console.log(son)</span><br></pre></td></tr></table></figure></p>
<p>在new Person()之后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Person.prototype.sleep = function() &#123;&#125; </span><br><span class="line">function Person(name, age) &#123; </span><br><span class="line">  this.name = name;  </span><br><span class="line">  this.age = age;  </span><br><span class="line">&#125;</span><br><span class="line">function Son(sex) &#123; </span><br><span class="line">  this.sex = sex;  </span><br><span class="line">&#125;</span><br><span class="line">Son.prototype = new  Person(); </span><br><span class="line">SOn.prototype.eat = function() &#123;&#125;; // 在这里... </span><br><span class="line">var son = new Son(&apos;male&apos;);  </span><br><span class="line">console.log(son)</span><br></pre></td></tr></table></figure></p>
<p>上述代码<strong>在new Person之前子类原型添加方法失败</strong>，原因是更改了原型的指向。<br>该继承缺点：无法实现多继承；<br>在子类原型添加方法和属性，需在Son.prototype=new  Person之后。</p>
<p><strong>call/apply构造函数继承</strong>，如果忘记可以查看上面call/apply介绍。<br>这里补充父类上原型属性和方法能否被call/apply继承。<br>相关代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.sleep = function() &#123;&#125; </span><br><span class="line">function Person(name, age) &#123; </span><br><span class="line">  this.name = name; </span><br><span class="line">  this.age = age;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Son.prototype.eat = function() &#123;&#125; </span><br><span class="line">function Son(name, age, sex) &#123; </span><br><span class="line">  Person.call(this, name, age); // ...能不能继承sleep函数 </span><br><span class="line">  this.sex = sex; </span><br><span class="line">&#125;</span><br><span class="line">var son = new Son(&apos;sunny&apos;, 18, &apos;male&apos;); </span><br><span class="line">console.log(son);</span><br></pre></td></tr></table></figure></p>
<p>实例son输出说明，call方法不能继承父类原型上的方法和属性；父类构造函数调用两次：一次在子类构造函数内调用，一次在创建子类原型调用。</p>
<p><strong>原型链与构造函数组合</strong><br>相关代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Person.prototype.sleep = function() &#123;&#125; </span><br><span class="line">function Person(name, age) &#123; </span><br><span class="line">  this.name = name; </span><br><span class="line">  this.age = age; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Son(name, age, sex)&#123; </span><br><span class="line">  Person.call(this, name, age); </span><br><span class="line">  this.sex = sex; </span><br><span class="line">&#125;</span><br><span class="line">Son.prototype = new Person(); // 第一步 </span><br><span class="line">Son.prototype.constructor = Son; // 第二步 </span><br><span class="line">Son.prototype.eat = function() &#123;&#125;; </span><br><span class="line">var son = new Son(&apos;sunny&apos;, 18, &apos;male&apos;); </span><br><span class="line">console.log(son)</span><br></pre></td></tr></table></figure></p>
<p>实例son输出说明，子类可以继承父类属性以及父类原型属性和方法；缺点父类的构造函数生成两份实例。</p>
<p><strong>组合继承</strong><br>通过子类原型和父类原型指向同一个对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Person.prototype.sleep = function() &#123;&#125;</span><br><span class="line">function Person(name, age) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Son(name, age, sex) &#123;</span><br><span class="line">  Person.call(this, name, age);</span><br><span class="line">  this.sex = sex;</span><br><span class="line">&#125;</span><br><span class="line">Son.prototype = Person.prototype; // ...在这里</span><br><span class="line">Son.prototype.eat = function() &#123;&#125;;</span><br><span class="line">var son = new Son(&apos;sunny&apos;, 18, &apos;male&apos;);</span><br><span class="line">console.log(son)</span><br></pre></td></tr></table></figure></p>
<p>代码son输出说明，子类可以继承父类原型上方法和属性。</p>
<p><strong>组合继承优化</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.sleep = function() &#123;&#125; </span><br><span class="line">function Person(name, age) &#123; </span><br><span class="line">  this.name = name; </span><br><span class="line">  this.age = age; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">function Son(name, age, sex) &#123; </span><br><span class="line">  Person.call(this, name, age); </span><br><span class="line">  this.sex = sex; </span><br><span class="line">&#125; </span><br><span class="line">Son.prototype = Object.create(Person.prototype); </span><br><span class="line">Son.prototype.constructor = Son; </span><br><span class="line">Son.prototype.eat = function() &#123;&#125;;</span><br><span class="line">var son = new Son(&apos;sunny&apos;, 18, &apos;male&apos;); </span><br><span class="line">console.log(son);</span><br></pre></td></tr></table></figure></p>
<p>实例son继承借助创建对象，子类继承父类所有属性和方法。</p>
<p><strong>函数共享原型</strong><br>对于指向同一个对象继承。<br>相关代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.name = &apos;sunny&apos;; </span><br><span class="line">function Person() &#123;&#125; </span><br><span class="line">function Son() &#123;&#125;  </span><br><span class="line">Son.prototype = Person.prototype; </span><br><span class="line">var son = new Son(); </span><br><span class="line">console.log(son.name); // sunny</span><br></pre></td></tr></table></figure></p>
<p>可以将代码整合优化，编写一个公共函数共享原型，一定要在new之前使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.name = &apos;sunny&apos;; </span><br><span class="line">function Person() &#123;&#125; </span><br><span class="line">function Son() &#123;&#125; </span><br><span class="line">// 编写inherit函数共享原型 </span><br><span class="line">function inherit(target, origin) &#123;  </span><br><span class="line">  target.prototype = origin.prototype;   </span><br><span class="line">&#125;</span><br><span class="line">inherit(Son, Person);  // new之前先继承后使用 </span><br><span class="line">var son = new Son(); </span><br><span class="line">console.log(son.name); // sunny</span><br></pre></td></tr></table></figure></p>
<p>继续对上面代码进行修改，在函数inherit内部使用一个构造函数中转proto指向。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Person.prototype.name = &apos;sunny&apos;; </span><br><span class="line">function Person() &#123;&#125; </span><br><span class="line">function Son() &#123;&#125;; </span><br><span class="line">function inherit(target, origin) &#123;  </span><br><span class="line">  function F()&#123; </span><br><span class="line">    F.prototype = origin.prototype; </span><br><span class="line">    target.prototype = new F(); </span><br><span class="line">    target.prototype.constructor = target; </span><br><span class="line">    target.prototype.uber = origin.prototype; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">inherit(Son, Person);</span><br><span class="line">var person = new Person();</span><br><span class="line">var son = new Son();</span><br><span class="line">console.log(son.name) // undefined </span><br><span class="line">console.log(person.name) // sunny </span><br><span class="line"></span><br><span class="line">// Son原型添加属性，不影响原构造函数与原 原型 </span><br><span class="line">Son.prototype.sex = &apos;male&apos;; </span><br><span class="line">console.log(son.sex) // male </span><br><span class="line">console.log(Person.sex) // undefined</span><br></pre></td></tr></table></figure></p>
<p>上述代码块中沿着目标实例son.<strong>proto</strong>找到构造函数F.prototype，指给原构造函数Person.prototype，此方法称为<strong>圣杯模式继承</strong>。</p>
<p>抽离核心代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var inherit = (function() &#123; </span><br><span class="line">  var F = function() &#123;&#125; </span><br><span class="line">  return function(target, origin) &#123; </span><br><span class="line">    F.prototype = origin.prototype; </span><br><span class="line">    target.prototype = new F(); </span><br><span class="line">    target.prototype.constructor = target; </span><br><span class="line">    target.prototype.uber = origin.prototype; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p>
<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>管理变量，防止污染全局，适用于模块化开发。<br>之前开发中使用对象形式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; </span><br><span class="line">  name: &apos;sunny&apos;, </span><br><span class="line">  sayName: function() &#123; </span><br><span class="line">    console.log(this.name) </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.sayName(); // 打印结果: sunny</span><br></pre></td></tr></table></figure></p>
<p>有了立即执行函数结合闭包，演变出以下改进。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;sunny&apos;;</span><br><span class="line">var init = (function()&#123;</span><br><span class="line">  var name = &apos;cherry&apos;;</span><br><span class="line">  function sayName() &#123;</span><br><span class="line">    console.log(name); // cherry</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return function() &#123;</span><br><span class="line">    sayName();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line">init();</span><br></pre></td></tr></table></figure></p>
<p>上述代码使用闭包形式通过私有属性执行。</p>
<h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><p>模仿jQuery链式调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.eat().drink.slee();</span><br></pre></td></tr></table></figure></p>
<p>浏览器控制台输出函数结果，会默认值返回undefined。利用对象方法中this指向当前对象，模仿jQuery链式调用，默认返回this即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; </span><br><span class="line">  eat: function() &#123; </span><br><span class="line">    console.log(&apos;eat&apos;); </span><br><span class="line">    return this; </span><br><span class="line">  &#125;,</span><br><span class="line">  drink: function() &#123;</span><br><span class="line">    console.log(&apos;drink&apos;); </span><br><span class="line">    return this; </span><br><span class="line">  &#125;,</span><br><span class="line">  sleep: function() &#123; </span><br><span class="line">    console.log(&apos;sleep&apos;); </span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line">obj.eat().drink().sleep();  // eat, drink, sleep</span><br></pre></td></tr></table></figure></p>
<h3 id="对象枚举"><a href="#对象枚举" class="headerlink" title="对象枚举"></a>对象枚举</h3><p>打印对象属性对应的值一般使用for…in 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  name: &apos;sunny&apos;, </span><br><span class="line">  age: 18 </span><br><span class="line">&#125;</span><br><span class="line">for(var prop in obj) &#123; </span><br><span class="line">  console.log(obj.prop); // undefined </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在接收对象值应该写成这样obj[prop]，因为在对象内部会隐式转换成obj.prop。</p>
<p>hasOwnProperty：检测该属性在该对象中是否存在。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; </span><br><span class="line">  name: &apos;sunny&apos;, </span><br><span class="line">  age: 18, </span><br><span class="line">  __proto__: &#123; </span><br><span class="line">    lastname: &apos;cherry&apos;, </span><br><span class="line">    __proto__: Object.prototype </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(var prop in obj) &#123; </span><br><span class="line">  if(obj.hasOwnProperty(prop)) &#123; </span><br><span class="line">    console.log(obj[prop]) // sunny, 18, cherry ... </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>只有对象能用hasOwnProperty。</li>
<li>是对象自己的属性返回true，反之false。</li>
<li>能返回原型及原型链上的属性，一旦延伸到原型链顶端不会找到该属性，返回false(系统自带的返回true，自己设置的返回true)。</li>
</ul>
<p>in：能不能访问对象属性，包括原型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; </span><br><span class="line">  name: &apos;sunny&apos;, </span><br><span class="line">  age: 18, </span><br><span class="line">  __proto__:&#123; </span><br><span class="line">    lastname: &apos;cherry&apos;, </span><br><span class="line">    __proto__: Object.prototype </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(&apos;name&apos; in obj) // true</span><br></pre></td></tr></table></figure></p>
<p>instanceof<br>官方解释：<br>A instanceof B，A对象是不是B构造函数构造出来的。<br>个人理解换种说法：A对象的原型上有没有B的原型。<br>相关代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;&#125; </span><br><span class="line">var person = new Person(); </span><br><span class="line">var obj = &#123;&#125;; </span><br><span class="line"></span><br><span class="line">person instanceof Person   // true </span><br><span class="line">person instanceof Object   // true </span><br><span class="line">[] instanceof Object       // true </span><br><span class="line">[] instanceof Array        // true </span><br><span class="line">obj instanceof Person      // false </span><br><span class="line">obj instanceof Array       // false</span><br></pre></td></tr></table></figure></p>
<p>通过上述代码发现数组与对象在instanceof中返回值，可以使用instanceof区分数组与对象。</p>
<p>数组与对象的区分还可以使用constructor和toString.call()。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var arr = []; </span><br><span class="line">var obj = &#123;&#125;; </span><br><span class="line">console.log(arr.constructor) // ƒ Array() &#123; [native code] &#125; </span><br><span class="line">console.log(obj.constructor) // ƒ Object() &#123; [native code] &#125; </span><br><span class="line"></span><br><span class="line">// toString.call() 在Object原型上属性 </span><br><span class="line">console.log(Object.prototype.toString.call(arr)) // [object Array] </span><br><span class="line">console.log(Object.prototype.toString.call(obj)) // [object Object]</span><br></pre></td></tr></table></figure></p>
<p>toString.call()可以实现深度克隆。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; </span><br><span class="line">  name: &apos;sunny&apos;, </span><br><span class="line">  age: 18, </span><br><span class="line">  car: [&apos;visa&apos;, &apos;BMW&apos;], </span><br><span class="line">  wife: &#123; </span><br><span class="line">    name: &apos;cherry&apos;, </span><br><span class="line">    son: &#123; </span><br><span class="line">      name: &apos;s&apos; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var targetObj = &#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>实现targetObj对象拥有对象obj所有属性。<br>思路：</p>
<ul>
<li>首先使用for…in遍历对象。</li>
<li>判断是否属于原始值，是数组还是对象。</li>
<li>建立相应数组与对象。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// ...</span><br><span class="line">function deepClone(target, origin) &#123; </span><br><span class="line">  var target = target || &#123;&#125;; </span><br><span class="line">  var toStr = Object.prototype.toString; </span><br><span class="line">  var arrStr = &apos;[object Array]&apos;; </span><br><span class="line">  </span><br><span class="line">  for(var prop in origin) &#123; </span><br><span class="line">    if(origin hasOwnProperty(prop)) &#123; </span><br><span class="line">      if(origin[prop] != &apos;null&apos; &amp;&amp;  </span><br><span class="line">          typeof(origin[prop]) == &apos;object&apos;) &#123; </span><br><span class="line">        target[prop] = (toStr.call(origin[prop]) == arrStr) </span><br><span class="line">        ? [] </span><br><span class="line">        : &#123;&#125;; </span><br><span class="line">        deepClone(target[prop], origin[prop]); </span><br><span class="line">      &#125;else&#123; </span><br><span class="line">        target[prop] = origin[prop]; </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return target;</span><br><span class="line">&#125;</span><br><span class="line">deepClone(targetObj, obj);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>相反，对象拥有简单属性类型，可以实现浅度克隆。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var obj = &#123; </span><br><span class="line">  name: &apos;sunny&apos;, </span><br><span class="line">  age: 18 </span><br><span class="line">&#125;</span><br><span class="line">var targetObj = &#123;&#125;; </span><br><span class="line"></span><br><span class="line">function clone(target, origin) &#123; </span><br><span class="line">  var target = target || &#123;&#125;; </span><br><span class="line">  for(var prop in origin) &#123; </span><br><span class="line">    if(origin.hasOwnProperty(prop)) &#123; </span><br><span class="line">      target[prop] = origin[prop] </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return target;</span><br><span class="line">&#125;</span><br><span class="line">clone(targetObj, obj);</span><br></pre></td></tr></table></figure></p>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><ul>
<li>this规则：</li>
<li>由new调用，绑定到新创建的对象。</li>
<li>由call/apply调用，绑定到指定的对象。</li>
<li>由上下文对象调用，绑定到那个上下文对象。</li>
<li>默认在严格模式下绑定到undefined，否则绑定到全局。</li>
</ul>
<p>这里补充this案例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;sunny&apos;; </span><br><span class="line">var obj = &#123; </span><br><span class="line">  name: &apos;cherry&apos;, </span><br><span class="line">  say: function() &#123; </span><br><span class="line">    console.log(this.name) </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var fn = obj.say; </span><br><span class="line">fn(); // sunny </span><br><span class="line">obj.say(); // cherry</span><br></pre></td></tr></table></figure></p>
<p>fn运行过程可以理解下面这样，把对象obj中函数say方法交给函数fn拥有，当前this就指向所在全局window。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// ...变量省略 </span><br><span class="line">var fn = say function () &#123; </span><br><span class="line">  console.log(this.name) </span><br><span class="line">&#125;</span><br><span class="line">// ...输出语句省略</span><br></pre></td></tr></table></figure>
<p>案例2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var foo = 123; </span><br><span class="line">function print() &#123; </span><br><span class="line">  var foo = 456; </span><br><span class="line">  this.foo = 789; </span><br><span class="line">  console.log(foo); </span><br><span class="line">&#125;</span><br><span class="line">print();</span><br></pre></td></tr></table></figure></p>
<p>可以使用上述规则④，this绑定到全局，因此运行函数输出 456。</p>
<p>案例3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var foo = 123; </span><br><span class="line">function Print() &#123; </span><br><span class="line">  this.foo = 234; </span><br><span class="line">  console.log(foo) </span><br><span class="line">&#125; </span><br><span class="line">new Print();</span><br></pre></td></tr></table></figure></p>
<p>函数Print运行，使用上述规则④，this绑定到全局，改变了全局foo值，当前构造函数Print没有this，沿着原型链向往寻找，最终在window上找到，因此new print()输出234。</p>
<p>arguments.callee<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log(arguments);</span><br><span class="line">  //Arguments(2) [1, 2, callee: ƒ, Symbol(Symbol.iterator): ƒ]</span><br><span class="line">  </span><br><span class="line">  console.log(arguments.callee);</span><br><span class="line">  // ƒ foo() &#123;</span><br><span class="line">  // console.log(arguments.callee)</span><br><span class="line">  // &#125;</span><br><span class="line"></span><br><span class="line">  console.log(arguments.callee == foo) // true</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">foo(1, 2);</span><br></pre></td></tr></table></figure></p>
<p>上述输出值，arguments.callee指运行时的函数。</p>
<p>fn.caller<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">  console.log(foo.caller) // foo函数</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure></p>
<p>上述代码输出值，fn.caller指函数自身foo。<br><strong>callee和caller在es5严格模式下都不能使用</strong>。</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>改变原数组</p>
<ul>
<li>push() 向数组最后一位添加</li>
<li>pop() 从最后一位开始剔出去</li>
<li>shift() 从数组前面删除</li>
<li>unshift() 在数组前面添加</li>
<li>reserver() 逆转数组</li>
<li>sort() 排序</li>
<li>splice(从第几位开始, 截取长度, 在切口处添加新的数据)</li>
</ul>
<p>不改变数组</p>
<ul>
<li>concat() //合并数组</li>
<li>slice(从该位置开始截, 截取到该位)</li>
<li>split() 返回字符串</li>
</ul>
<h3 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h3><p>类数组必须有length属性，能像数组/对象一样使用。<br>原始类型的值不能拥有属性和方法。</p>
<p>如何使用：<br>自动创建(看生命周期)，自动销毁(调用完函数之后)</p>
<p>典型类数组arguments<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function foo() &#123; </span><br><span class="line">  console.log(arguments) </span><br><span class="line">&#125;</span><br><span class="line">foo(1, 2, 3);</span><br></pre></td></tr></table></figure></p>
<p>向类数组push<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; </span><br><span class="line">  &apos;2&apos;: &apos;a&apos;, </span><br><span class="line">  &apos;3&apos;: &apos;b&apos;, </span><br><span class="line">  &apos;length&apos;: 2, </span><br><span class="line">  &apos;push&apos;: Array.prototype.push, </span><br><span class="line">  &apos;splice&apos;: Array.prototype.splice </span><br><span class="line">&#125;</span><br><span class="line">obj.push(&apos;d&apos;); </span><br><span class="line">console.log(obj) </span><br><span class="line">// &#123;2: &quot;d&quot;, 3: &quot;b&quot;, length: 3, push: ƒ&#125; </span><br><span class="line"></span><br><span class="line">obj.push(&apos;f&apos;); </span><br><span class="line">console.log(obj); </span><br><span class="line">// &#123;2: &quot;d&quot;, 3: &quot;f&quot;, length: 4, push: ƒ&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过输出，push后类对象length递增，类对象属性为索引，索引最大length-1，根据当前length-1取索引值。</p>
<h3 id="try…catch"><a href="#try…catch" class="headerlink" title="try…catch"></a>try…catch</h3><p>规则</p>
<ul>
<li>try里面发生错误，不会执行错误后try里面的代码。</li>
<li>如果try里面没有报错，不会执行catch里面代码；反之会执行catch里面代码。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try&#123; </span><br><span class="line">  console.log(&apos;ok&apos;) </span><br><span class="line">&#125;catch(e) &#123; </span><br><span class="line">  console.log(&apos;error&apos;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>归纳六种error信息</p>
<ul>
<li>EvalError：eval的使用与定义不一致。</li>
<li>RangeRrror：数值越界。</li>
<li>ReferenceError：非法或不能识别的引用数组。</li>
<li>SyntaxError：发生语法解析错误。</li>
<li>TypeError：操作数据类似错误。</li>
<li>URIRrror：URI处理函数使用不当。</li>
</ul>
<p>ES5严格模式<br>使用’use strict’(字符串，反之代表是JS语句，JS语句没有规定这种写法)启动严格模式 遵循es5.0模式，不再兼容es3一些不规则语法，推荐局部。</p>
<p>不支持 with/arguments/callee/caller，变量赋值前必须声明。</p>
<p>局部this必须被赋值，赋值什么就是什么，拒绝重复属性和参数，不能使用eval()。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var obj = &#123;&#125;; </span><br><span class="line">var name = &apos;window&apos;;</span><br><span class="line">function foo() &#123;</span><br><span class="line">  var name = &apos;scope&apos;;</span><br><span class="line">  with(obj) &#123; // with改变作用域链</span><br><span class="line">    console.log(name); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<p>es5.0与es3.0规则</p>
<ul>
<li>浏览器基于es3.0方法 + es5.0新增方法。</li>
<li>es3.0与es5.0发生冲突部分，使用es5.0模式，反之使用es3.0模式。</li>
</ul>

      
    </div>

    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;padding-top:20px;">———— / END / ————</div>
    
</div>
      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/archives/688af21b.html" rel="next" title="学习Html">
                <i class="fa fa-chevron-left"></i> 学习Html
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/archives/4822cc7.html" rel="prev" title="常见的CSS布局">
                常见的CSS布局 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        
  <div class="bdsharebuttonbox">
    <a href="#" class="bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a>
    <!--a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a-->
    <a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a>
    <a href="#" class="bds_tieba" data-cmd="tieba" title="分享到百度贴吧"></a>
    <!--a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a-->
    <!--a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a-->
    <!--a href="#" class="bds_douban" data-cmd="douban" title="分享到豆瓣网"></a-->
    <!--a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a-->
    <a href="#" class="bds_more" data-cmd="more"></a>
    <a class="bds_count" data-cmd="count"></a>
  </div>
  <script>
    window._bd_share_config = {
      "common": {
        "bdText": "",
        "bdMini": "2",
        "bdMiniList": false,
        "bdPic": ""
      },
      "share": {
        "bdSize": "16",
        "bdStyle": "0"
      }
    }
  </script>

<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/cc-bf-chglyn.png" alt="Changyuan">
          <p class="site-author-name" itemprop="name">Changyuan</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">24</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">29</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="https://www.baidu.com" title="baidu" target="_blank">baidu</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://relign.github.io" title="relignBlog" target="_blank">relignBlog</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.zhangtaifeng.com" title="zhangtaifeng" target="_blank">zhangtaifeng</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://lmaomaoz.com/blog2" title="lmaomaoz" target="_blank">lmaomaoz</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#var"><span class="nav-number">1.</span> <span class="nav-text">var</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#typeof"><span class="nav-number">2.</span> <span class="nav-text">typeof</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据类型"><span class="nav-number">3.</span> <span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数"><span class="nav-number">4.</span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Global-Object-GO"><span class="nav-number">5.</span> <span class="nav-text">Global Object(GO)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#闭包"><span class="nav-number">6.</span> <span class="nav-text">闭包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#作用域"><span class="nav-number">7.</span> <span class="nav-text">作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#作用域链"><span class="nav-number">8.</span> <span class="nav-text">作用域链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#立即执行函数"><span class="nav-number">9.</span> <span class="nav-text">立即执行函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象模型"><span class="nav-number">10.</span> <span class="nav-text">对象模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#new关键字"><span class="nav-number">11.</span> <span class="nav-text">new关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#包装类"><span class="nav-number">12.</span> <span class="nav-text">包装类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原型"><span class="nav-number">13.</span> <span class="nav-text">原型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原型链"><span class="nav-number">14.</span> <span class="nav-text">原型链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-create"><span class="nav-number">15.</span> <span class="nav-text">Object.create</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#call-继承"><span class="nav-number">16.</span> <span class="nav-text">call (继承)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#apply-继承"><span class="nav-number">17.</span> <span class="nav-text">apply (继承)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#继承"><span class="nav-number">18.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#命名空间"><span class="nav-number">19.</span> <span class="nav-text">命名空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#链式调用"><span class="nav-number">20.</span> <span class="nav-text">链式调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象枚举"><span class="nav-number">21.</span> <span class="nav-text">对象枚举</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#this"><span class="nav-number">22.</span> <span class="nav-text">this</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组"><span class="nav-number">23.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类数组"><span class="nav-number">24.</span> <span class="nav-text">类数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#try…catch"><span class="nav-number">25.</span> <span class="nav-text">try…catch</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  京ICP备13052054号-1
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love animation-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">园子</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io" rel="external nofollow">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next" rel="external nofollow">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="//cdn.jsdelivr.net/jquery/2.1.3/jquery.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/fastclick/1.0.6/fastclick.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/jquery.lazyload/1.9.3/jquery.lazyload.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.ui.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  
    
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "http://blog.yuanbeauty.com",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
  







  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    bp.src = (curProtocol === 'https') 
    ? 'https://zz.bdstatic.com/linksubmit/push.js'
    : 'http://push.zhanzhang.baidu.com/push.js';
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  


  

</body>
</html>
