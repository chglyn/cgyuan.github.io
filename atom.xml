<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>园子</title>
  
  <subtitle>或许为了自身写，或许为了知己写！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.yuanbeauty.com/"/>
  <updated>2020-07-21T16:00:00.000Z</updated>
  <id>http://blog.yuanbeauty.com/</id>
  
  <author>
    <name>Changyuan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>编写 jQuery postFrom 表单插件</title>
    <link href="http://blog.yuanbeauty.com/archives/2a58e9cf.html"/>
    <id>http://blog.yuanbeauty.com/archives/2a58e9cf.html</id>
    <published>2020-07-21T16:00:00.000Z</published>
    <updated>2020-07-21T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>项目需求：</p><p>选课界面，选择多个课程添加到购物车计算总价。添加到购物车的课程，点击“提交结算”跳转到订单确认列表，当前界面要呈现上个界面选择的课程，包括：课程名称，课程价格，课程班级等等。</p><p>解决方式：</p><p>使用 <code>get</code> 方式传参，该方法行不通。因为浏览器 <code>url</code> 承载内容较多况且也有限制大小。所以使用 <code>post</code> 方式提交数据，在下个界面接受上个界面传来的数据列表。</p><p>使用 <code>post</code> 提交，不能使用 <code>jQuery</code> 自带封装好的 <code>post</code> 方式提交数据。既然这样，得自己封装一个 <code>post</code> 提交数据。</p><p>步骤：</p><ul><li><p>使用 <code>extend</code> 封装一个 <code>post</code> 方法。</p></li><li><p>该 <code>post</code> 方法传入 <code>url</code> 参数和 <code>args</code> 参数，其中 <code>url</code> 是要跳转到下个界面的路径；<code>args</code> 是传入的数据，比如这里是添加到购物车的课程。</p></li><li><p>声明 <code>from</code>，<code>input</code> 变量；并且设置 <code>from</code> 的 <code>url</code> 地址。</p></li><li><p>遍历 <code>args</code> 参数，把每一条数据的具体值，绑定到 <code>input</code> 上面并设置 <code>type=&#39;hidden&#39;</code> 不可见。</p></li><li><p>遍历结束，<code>input</code> 追加到 <code>from</code> 上面；<code>from</code> 追加到 <code>body</code> 上面。</p></li><li><p>设置 <code>from</code> 提交，提交成功后，自动销毁。</p></li></ul><p>完整代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$.extend(&#123;</span><br><span class="line">StandardPost:function(url, args) &#123;</span><br><span class="line">var form = $(&quot;&lt;form method=&apos;post&apos; style=&apos;display:none&apos;&gt;&lt;/form&gt;&quot;), input;</span><br><span class="line">form.attr(&#123; &quot;action&quot;:url &#125;);</span><br><span class="line">$.each(args,function(key2,value2) &#123;</span><br><span class="line">$.each(value2,function(key,value) &#123;</span><br><span class="line">input = $(&quot;&lt;input type=&apos;hidden&apos;&gt;&quot;);</span><br><span class="line">input.attr(&#123; &quot;name&quot;:&apos;objectArray[&apos;+key2+&apos;][&apos;+key+&apos;]&apos;&#125;);</span><br><span class="line">input.val(value);</span><br><span class="line">form.append(input);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">form.appendTo($(&apos;body&apos;));</span><br><span class="line">form.submit();</span><br><span class="line">form.remove();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;项目需求：&lt;/p&gt;
&lt;p&gt;选课界面，选择多个课程添加到购物车计算总价。添加到购物车的课程，点击“提交结算”跳转到订单确认列表，当前界面要呈现上个界面选择的课程，包括：课程名称，课程价格，课程班级等等。&lt;/p&gt;
&lt;p&gt;解决方式：&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;get&lt;/co
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://blog.yuanbeauty.com/categories/JavaScript/"/>
    
      <category term="jQuery postFrom" scheme="http://blog.yuanbeauty.com/categories/JavaScript/jQuery-postFrom/"/>
    
    
  </entry>
  
  <entry>
    <title>浏览器 Url 参数转化为对象</title>
    <link href="http://blog.yuanbeauty.com/archives/14ec002f.html"/>
    <id>http://blog.yuanbeauty.com/archives/14ec002f.html</id>
    <published>2020-06-20T16:00:00.000Z</published>
    <updated>2020-06-20T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>项目需求：</p><p>教师端，题库列表界面需要传入 <code>n</code> 个参数，后续还有可能新增参数。由于是旧项目后端在 <code>url</code> 路由设置参数，后续开发也不方便。因此，由前端自定义传参接收参数。</p><p>使用一般方式获取浏览器路有参数，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var search = window.location.search;</span><br><span class="line"></span><br><span class="line">if(search.indexOf(&apos;?&apos;) != -1) &#123;</span><br><span class="line">var val = search.split(&apos;?&apos;)[1];</span><br><span class="line">val = val.split(&apos;&amp;&apos;).slice(-1)[0];</span><br><span class="line">val = val.split(&apos;=&apos;)[1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方式单独获取具体参数可以使用，如果获取多个参数就得考虑使用正则或者封装公共方法。</p><p>如何获取多个浏览器 <code>url</code> 参数？</p><p>下面是自己编写的方法，把浏览器参数存入对象中，以键值对的方式存在对象中。</p><p>步骤：</p><ul><li><p>获取浏览器参数，使用 <code>window.location.search</code>。</p></li><li><p>使用 <code>split</code> 切割参数取下标为 1 的数据。</p></li><li><p>声明一个全局对象，保存参数数据。</p></li><li><p>使用 <code>split</code> 切割 <code>&amp;</code> 符号。</p></li><li><p>循环遍历上一步骤的数组，使用 <code>split</code> 切割数组每项中的数据，以 <code>=</code> 为切割点。</p></li><li><p>设置每项的数据下标 <code>0</code> 为对象的键名，<code>1</code> 为对象的键值。</p></li><li><p>循环结束后，返回该对象。</p></li></ul><p>完整代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function getUrlParams(name) &#123;</span><br><span class="line">    var search = url.split(&apos;?&apos;) &amp;&amp; url.split(&apos;?&apos;)[1];</span><br><span class="line">    var obj = &#123; &#125;;</span><br><span class="line">    search = search.split(&apos;&amp;&apos;);</span><br><span class="line">    for(var i=0; i &lt; search.length; i++) &#123;</span><br><span class="line">        var search_v = search[i].split(&apos;=&apos;);</span><br><span class="line">        obj[search_v[0]] = search_v[1];</span><br><span class="line">    &#125;</span><br><span class="line">return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;项目需求：&lt;/p&gt;
&lt;p&gt;教师端，题库列表界面需要传入 &lt;code&gt;n&lt;/code&gt; 个参数，后续还有可能新增参数。由于是旧项目后端在 &lt;code&gt;url&lt;/code&gt; 路由设置参数，后续开发也不方便。因此，由前端自定义传参接收参数。&lt;/p&gt;
&lt;p&gt;使用一般方式获取浏览器路
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://blog.yuanbeauty.com/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>计算某天日期</title>
    <link href="http://blog.yuanbeauty.com/archives/1bbd2904.html"/>
    <id>http://blog.yuanbeauty.com/archives/1bbd2904.html</id>
    <published>2020-05-09T16:00:00.000Z</published>
    <updated>2020-05-09T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>项目需求：</p><p>根据现有日期，计算前几天日期或后几天的日期。</p><p>解决方式：</p><p>顺便编写一个公共方法，方便后续使用。使用 <code>setDate</code> 计算已知日期加上固定天数；日期转化成字符串使用 <code>padStart</code> 不足两位的补全 0。</p><p>完整代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">export default&#123;</span><br><span class="line">methods: &#123;</span><br><span class="line">initDate(day) &#123;</span><br><span class="line">let timeDate,Y,M,D,h,m,s;</span><br><span class="line">timeDate = new Date();</span><br><span class="line">timeDate.setDate(timeDate.getDate() + day);</span><br><span class="line">Y = timeDate.getFullYear();</span><br><span class="line">M = (timeDate.getMonth() + 1).toString().padStart(2, &apos;0&apos;);</span><br><span class="line">D = timeDate.getDate().toString().padStart(2, &apos;0&apos;);</span><br><span class="line">h = timeDate.getHours().toString().padStart(2, &apos;0&apos;);</span><br><span class="line">m = timeDate.getMinutes().toString().padStart(2, &apos;0&apos;);</span><br><span class="line">s = timeDate.getSeconds().toString().padStart(2, &apos;0&apos;);</span><br><span class="line">return `$&#123;Y&#125;-$&#123;M&#125;-$&#123;D&#125; $&#123;h&#125;:$&#123;m&#125;:$&#123;s&#125;`;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;项目需求：&lt;/p&gt;
&lt;p&gt;根据现有日期，计算前几天日期或后几天的日期。&lt;/p&gt;
&lt;p&gt;解决方式：&lt;/p&gt;
&lt;p&gt;顺便编写一个公共方法，方便后续使用。使用 &lt;code&gt;setDate&lt;/code&gt; 计算已知日期加上固定天数；日期转化成字符串使用 &lt;code&gt;padStart&lt;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://blog.yuanbeauty.com/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>Hexo个人博客绑定域名</title>
    <link href="http://blog.yuanbeauty.com/archives/8a6c9ade.html"/>
    <id>http://blog.yuanbeauty.com/archives/8a6c9ade.html</id>
    <published>2020-04-05T16:00:00.000Z</published>
    <updated>2020-04-05T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p>申请域名已经很久，之前偶尔用用，没有用起来；最近想充分利用，在网上研究一番，现在配置成功可以使用，记下心得。</p><h3 id="申请域名"><a href="#申请域名" class="headerlink" title="申请域名"></a>申请域名</h3><p>在万网，新网等网站申请一个域名。本文以万网为例：</p><ul><li><p>首先注册阿里云账号，如果有淘宝账号的，可以直接登录。</p></li><li><p>登录以后，先进行实名认证（购买域名要用到）。</p></li><li><p>认证信息提交完毕后，可能需要一两天的审核时间。</p></li><li><p>认证完毕后回到首页，上方导航栏，产品-&gt;点击万网，搜索自己想要的域名并进行购买（域名持有者选择个人，这里就用到之前的认证）。</p></li><li><p>购买完毕后，回到首页点击右上方的控制台，进入后点击上方导航栏的产品与服务，然后选择域名，点击进入域名解析列表，然后就可以看到刚刚买的域名了，接下来进行解析配置（绑定）。</p></li></ul><h3 id="解析域名"><a href="#解析域名" class="headerlink" title="解析域名"></a>解析域名</h3><p>登录成功阿里云，进入个人页面找到<strong>最近使用的产品</strong>文案，点击域名进入域名管理页面：</p><p><img src="/images/1_6.png" alt="域名"></p><p>在域名列表中找到自己想要解析的域名，点击域名右侧<code>解析</code>文案：</p><p><img src="/images/1_7.png" alt="域名列表"></p><p>进入到域名解析设置页面，如下图：</p><p><img src="/images/1_8.png" alt="域名解析设置"></p><ul><li><p>第一个红色框中，点击修改在<code>记录值</code>中填写自己的<code>github</code>博客地址，不需要<code>http://</code>前缀。</p></li><li><p>第二个红色框中，填写博客站点的<code>IP</code>，获取博客<code>IP</code>方式：</p></li></ul><p><code>win+R</code>快捷键打开“运行”窗口，输入<code>cmd</code>运行命令行控制台。</p><p>用以下指令获取自己博客站点的<code>IP</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping xxx.github.io</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">正在 Ping xxx.github.io [185.xxx.xxx.153] 具有 32 字节的</span><br><span class="line">来自 xxx.xxx.xxx.xxx 的回复: 字节=32 时间=57ms TTL=48</span><br><span class="line">来自 xxx.xxx.xxx.xxx 的回复: 字节=32 时间=55ms TTL=48</span><br><span class="line">来自 xxx.xxx.xxx.xxx 的回复: 字节=32 时间=56ms TTL=48</span><br><span class="line">来自 xxx.xxx.xxx.xxx 的回复: 字节=32 时间=60ms TTL=48</span><br></pre></td></tr></table></figure><p>把获取到的<code>IP</code>填写在第二个红色框中。</p><h3 id="创建CNAME"><a href="#创建CNAME" class="headerlink" title="创建CNAME"></a>创建CNAME</h3><p>在本地博客站点路径下的source文件夹里，创建一个名为CNAME的文件（注意要大写），里面写上你之前购买的域名。</p><p>如下图：</p><p><img src="/images/1_9.png" alt="填写CNAME"></p><p>文件里的域名前加不加www都可以，具体规则如下：</p><ul><li>如果填写的是没有<code>www</code>的，比如 yuanbeauty.com，无论是访问 <code>http://www.yuanbeauty.com</code> 还是 <code>http://yuanbeauty.com</code> ，都会自动跳转到 <code>http://yuanbeauty.com</code>。</li></ul><ul><li>如果你填写的是其它子域名，比如 <code>abc.yuanbeauty.com</code>，访问 <code>http://abc.yuanbeauty.com</code> 没问题，但是访问 <code>http://yuanbeauty.com</code> ，不会自动跳转到 <code>http://abc.yuanbeauty.com</code>。</li></ul><h3 id="github绑定域名"><a href="#github绑定域名" class="headerlink" title="github绑定域名"></a>github绑定域名</h3><p>在<a href="https://github.com" target="_blank" rel="noopener">github</a>上，点击进入头像个人设置，如下图：</p><p><img src="/images/1_3.png" alt="setting"></p><p>点击存放个人博客的仓库，在<strong>仓库标题</strong>下面，有<code>setting</code>设置点击进入，</p><p><img src="/images/1_4.png" alt="setting"></p><p>在当前页面拉动滚动条找到<code>GitHub Pages</code>，填入购买的域名：</p><p><img src="/images/1_5.png" alt="github-pages"></p><p>重新生成个人博客，打包部署就能使用域名访问博客，执行命令：</p><ul><li><p><code>hexo clean</code> 清理缓存文件</p></li><li><p><code>hexo g</code> 生成静态文件</p></li><li><p><code>hexo d</code> 部署个人博客项目</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;申请域名已经很久，之前偶尔用用，没有用起来；最近想充分利用，在网上研究一番，现在配置成功可以使用，记下心得。&lt;/p&gt;
&lt;h3 id=&quot;申请域名&quot;&gt;&lt;a href=&quot;#申请域名&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="Hexo" scheme="http://blog.yuanbeauty.com/categories/Hexo/"/>
    
      <category term="绑定域名" scheme="http://blog.yuanbeauty.com/categories/Hexo/%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/"/>
    
    
  </entry>
  
  <entry>
    <title>一小时的时间，入门 Webpack</title>
    <link href="http://blog.yuanbeauty.com/archives/d51a4c5a.html"/>
    <id>http://blog.yuanbeauty.com/archives/d51a4c5a.html</id>
    <published>2020-03-20T16:00:00.000Z</published>
    <updated>2020-03-20T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前端构建工具 <code>Webpack</code> 最近特火，火到 <code>Vue</code>/<code>React</code> 官方推出的脚手架都是基于 <code>Webpck</code> 打造的。</p><p>为了更了解 <code>Webpack</code>，特意实打实地安装配置 <code>Webpack</code>。对以后进阶学习也能夯实基础，现在一起学习入门级的 <code>Webpack</code> 吧！</p><h3 id="认识-Webpack"><a href="#认识-Webpack" class="headerlink" title="认识 Webpack"></a>认识 Webpack</h3><p>先来观察应用 <code>Webpack</code> 能做的事：</p><p><img src="/images/webpack1-1.jpg" alt="webpack"></p><p>从图中得出：<code>Webpack</code> 能打包所有 <code>JS</code> 脚本；能打包所有 <code>style</code> 样式；能打包所有图片；能打包所有预编译语言。通俗的理解就是<strong>能打包前端所有资源</strong>。</p><h3 id="安装-Webpack"><a href="#安装-Webpack" class="headerlink" title="安装 Webpack"></a>安装 Webpack</h3><p>首先确保你已经安装了 <code>Node.js</code> 和 <code>Git</code>。找到存放项目的目录，在该目录下初始化项目。在终端执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm init</span><br><span class="line">// 或者</span><br><span class="line">$ npm init -y</span><br></pre></td></tr></table></figure><p>初始化后生成一个 <code>package.json</code> 文件，大致内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;webpack&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;study-webpack&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;keywords&quot;: [</span><br><span class="line">    &quot;study-webpack&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;author&quot;: &quot;yuan&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了后续快速安装其他依赖，这里使用淘宝镜像。在终端执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>接来下安装 <code>Webpack</code>，在 <code>npm</code> 官网查询安装手册。在终端执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ cnpm install --save-dev webpack</span><br><span class="line">// 或者</span><br><span class="line">$ yarn add webpack --dev</span><br></pre></td></tr></table></figure><p>附：使用 <code>yarn</code> 语法安装，确保已经安装 <code>yarn</code>。</p><p>注意：最新版本 <code>Webpack</code> 中 <code>webpack-cli</code> 从中分离了出来需要单独安装。在终端执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cnpm i webpack-cli --save-dev</span><br></pre></td></tr></table></figure><p>安装完 <code>Webpack</code> 之后需要其运行起来，得需要一个配置文件，其名称为 <code>webpack.config.js</code>，不能为其他名称。如果是其他名称 <code>Webpack</code> 找不到该配置文件，就抛出错误提示。</p><h3 id="运行-Webpack"><a href="#运行-Webpack" class="headerlink" title="运行 Webpack"></a>运行 Webpack</h3><p>查询官网手册后，填写 <code>webpack.config.js</code> 配置。对 <code>entry</code> 属性值和 <code>filename</code> 属性值进行简单修改，<code>webpack.config.js</code>  大致内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &apos;./src/index.js&apos;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">    filename: &apos;bundle.js&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>module.exports</code> 导出一个对象，其中：</p><p><code>entry</code> 表示打包资源入口，该字段属性值可以是 <code>String</code> / <code>Array</code> / <code>Object</code>。</p><p><code>output</code> 表示打包资源出口，也就是经打包的资源从该口输出。</p><p><code>dist</code> 是 <code>Webpack</code> 打包完成后存放资源的目录。</p><p>配置完内容后，在根目录下创建目录 <code>src</code>，里面编写一个叫 <code>index.js</code> 脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// index.js</span><br><span class="line">document.write(&apos;Hello Webpack!&apos;);</span><br></pre></td></tr></table></figure><p>为了方便看效果，在根目录下创建一个 <code>index.html</code> 模版，并引入打包后的资源 <code>bundle.js</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">  &lt;title&gt;入门webpack&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&lt;script src=&quot;./dist/bundle.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>使用预定义命令启动 <code>Webpack</code>，可以在 <code>package.json</code> 文件中的 <code>scripts</code> 字段中添加命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;webpack&quot;,</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  // ...</span><br></pre></td></tr></table></figure><p>在终端执行 <code>cnpm start</code> 打包完成后会看到在根目录下生成 <code>dist</code> 目录，里面包含 <code>bundle.js</code> 脚本，在浏览器端运行 <code>index.html</code> 可以看到页面输出 <code>Hello Webpack</code>！。</p><p>到此完成了 <code>Webpack</code> 初步的打包。</p><p>执行 <code>Webpack</code> 打包时，终端执行输出一些信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Hash: 9d157b09dd8d37122dad</span><br><span class="line">Version: webpack 4.42.1</span><br><span class="line">Time: 560ms</span><br><span class="line">Built at: 2020-04-19 11:48:36</span><br><span class="line">    Asset       Size  Chunks             Chunk Names</span><br><span class="line">bundle.js  961 bytes       0  [emitted]  main</span><br><span class="line">Entrypoint main = bundle.js</span><br><span class="line">[0] ./src/index.js 31 bytes &#123;0&#125; [built]</span><br></pre></td></tr></table></figure><ul><li><p><code>Hash</code> 表示当前文件打包生成的 <code>hash</code> 值，文件改变，<code>hash</code> 值就会变。</p></li><li><p><code>Version</code> 表示项目当前安装 <code>Webpack</code> 的版本。</p></li><li><p><code>Time</code> 表示项目打包所花费的时间。</p></li><li><p><code>Build</code> 表示项目打包日期，打包生成文件名称和文件大小</p></li><li><p><code>Entrypoint</code> 表示项目打包入口点。</p></li></ul><p>即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &apos;./src/index.js&apos;,</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 等价于</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: &apos;./src/index.js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>chunks</code>: 打包文件的 <code>id</code>，现在只有一个 <code>bundle.js</code> 打包文件，有多个的时候，会有多个不同的 <code>chunk</code>。</p></li><li><p><code>Chunk Names</code>: 打包文件的名字。</p></li></ul><p>最后一行表示打包生成的文件路径。</p><p>大多数网站中都会使用缓存，减少页面加载时长。</p><p><code>Webpack</code> 打包也可以做到这点，把之前的 <code>bundle.js</code> 改成带有 <code>hash</code> 值。</p><p>修改后的 <code>webpack.config.js</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line"> </span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &apos;./src/index.js&apos;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">    filename: &apos;[hash].js&apos; // hash</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>重新运行 <code>cnpm start</code> 打包完成后会看到根目录下生成 <code>dist</code> 目录，里面包含带 <code>hash</code> 值的资源。如果想缩短 <code>hash</code> 值，可以进行截取长度，比如：<code>[hash:6]</code>。</p><p>如果想要优化打包后的资源和想使用 <code>Webpack</code> 强大的功能，请继续往下看。</p><h3 id="认识-Plugin"><a href="#认识-Plugin" class="headerlink" title="认识 Plugin"></a>认识 Plugin</h3><p><code>plugin</code> 是 <code>Webpack</code> 的核心，<code>Webpack</code> 自身的多数功能都是用这个插件接口，让 <code>Webpack</code> 打包变得极其灵活。</p><p>经过认识 <code>Webpack</code> 初次打包后，发现每次执行 <code>cnpm start</code> 打包完成后都会在 <code>dist</code> 目录中追加打包生成后的新资源。造成 <code>dist</code> 文件很大。这时 <code>clean-webpack-plugin</code> 就可以登场，帮助我们解决这个问题。</p><p>在 <code>npm</code> 官网搜索该插件，点击名称进入详情查看安装手册，在终端执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ cnpm i --save-dev clean-webpack-plugin</span><br></pre></td></tr></table></figure><p>在 <code>webpack.config.js</code> 中添加该配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">const &#123; CleanWebpackPlugin &#125; =require(&apos;clean-webpack-plugin&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    new webpack.ProgressPlugin(),</span><br><span class="line">    new CleanWebpackPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在终端执行 <code>cnpm start</code> 会看到上一次打包生成的资源自动删除后，重新创建新的打包资源。</p><p>如果在项目中要引入打包后的资源，并且该资源带有 <code>hash</code> 值时不易方便使用，脚本太多也不易区分，这时可以使用 <code>Webpack</code> 提供的 <code>HTML</code> 模版插件解决问题。</p><p>在 <code>npm</code> 官网搜索该插件，点名称进去查看安装手册，在终端执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ cnpm i --save-dev html-webpack-plugin</span><br></pre></td></tr></table></figure><p>安装成功后，在根目录 <code>package.json</code> 中的 <code>devDependencies</code> 里能看到该插件和该插件的版本。</p><p>在 <code>Webpack</code> 中配置该插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &apos;./src/index.js&apos;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">    filename: &apos;[hash:6].js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new HtmlWebpackPlugin() // htmlPlugin</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在终端执行 <code>cnpm start</code> 会看到在根目录下生成 <code>dist</code> 目录，里面包含带 <code>hash</code> 值的资源和压缩过的 <code>index.html</code>。</p><p>如果不想使用压缩过的资源，可以在 <code>webpack.config.js</code> 中进行配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// ...</span><br><span class="line">module.exports = &#123; </span><br><span class="line">  mode: &quot;development&quot;,</span><br><span class="line">// ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据 <code>mode</code> 参数 <code>Webpack</code> 会区分是生产环境还是开发环境。一般生成环境 <code>mode</code> 设置为 <code>production</code>，开发环境设置为 <code>development</code>。</p><p>设置完成后，在终端执行 <code>cnpm start</code> 打包完成后，然后在浏览器上运行 <code>index.html</code> 可以看到输出内容没变化，页面代码没有压缩。</p><p>如果想对 <code>src/index.html</code> 做一些调整，比如：修改 <code>title</code>，创建多个模版文件，多个模版文件引入不同的脚本等等；只需要在 <code>new HtmlWebpackPlugin()</code> 中添加一些配置项就能解决。</p><p>比如修改 <code>title</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  // ...</span><br><span class="line">     new HtmlWebpackPlugin(&#123;</span><br><span class="line">        title: &apos;学习webpack&apos;</span><br><span class="line">     &#125;)</span><br><span class="line">  // ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在终端执行 <code>cnpm start</code> 打包完成后，在浏览器上运行 <code>index.html</code> 会看到 <code>title</code> 的变化。</p><p>项目难免会美化页面，那么就得给页面添加一些样式，可以写在单独文件中，可以写在 <code>.html</code> 模版中，这时处理 <code>CSS</code> 可以使用 <code>css-loader</code> 解决问题。</p><h3 id="认识-loader"><a href="#认识-loader" class="headerlink" title="认识 loader"></a>认识 loader</h3><p><code>loader</code> 用于对模块的源代码进行转换。<code>loader</code> 可以在 <code>import</code> 或”加载”模块时预处理文件。可以将文件从不同的语言（如 <code>TypeScript</code>）转换为 <code>JavaScript</code>，或将内联图像转换为 <code>data URL</code>。<code>loader</code> 甚至允许直接在 <code>JavaScript</code> 模块中 <code>import CSS</code> 文件。</p><p>①、处理 CSS</p><p>首先安装处理 <code>CSS</code> 相应的 <code>loader</code>：<code>css-loader</code> 和 <code>style-loader</code>。</p><p>在 <code>npm</code> 官网搜索该 <code>loader</code>，点击名称进去查看安装手册，在终端执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ cnpm i --save-dev css-loader style-loader</span><br></pre></td></tr></table></figure><ul><li><p><code>css-loader</code> 处理以 <code>.css</code> 后缀的文件。</p></li><li><p><code>style-loader</code> 经过 <code>css-loader</code> 处理过的 <code>CSS</code> 插入到 <code>DOM</code> 中。</p></li></ul><p>安装成功后，在根目录 <code>package.json</code> 中的 <code>devDependencies</code> 里能看到该 <code>loader</code> 和该 <code>loader</code> 的版本。</p><p>在 <code>webpack.config.js</code> 中添加处理 <code>CSS</code> 的 <code>loader</code> 配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // ...</span><br><span class="line">  module: &#123;</span><br><span class="line">      rules: [</span><br><span class="line">        &#123;</span><br><span class="line">          test: /\.css$/,</span><br><span class="line">          use: [ </span><br><span class="line">            &#123; loader: &quot;style-loader&quot; &#125;,  </span><br><span class="line">            &#123; loader: &quot;css-loader&quot; &#125; </span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">  &#125;,</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<code>use</code> 选项顺序，先使用 <code>css-loader</code> 再使用 <code>style-loader</code>。</p><p>项目中一般都是使用单独文件写入样式，这里使用以 <code>.css</code> 为后缀的文件负责控制页面样式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*&#123; margin:0px;padding:0px;&#125;</span><br><span class="line">body&#123; background: red; &#125;</span><br></pre></td></tr></table></figure><p>在根目录 <code>src/index.js</code> 中引入该样式文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.write(&apos;hello webpack&apos;) </span><br><span class="line">require(&apos;./style.css&apos;)</span><br></pre></td></tr></table></figure><p>在终端执行 <code>cnpm start</code> 打包完成后，在浏览器上运行 <code>index.html</code>，能看到页面背景色变红色。使用开发者工具也能看到页面插入 <code>style</code> 标签，<code>style</code> 标签里面嵌入刚刚写的样式：</p><p><img src="/images/webpack1-2.jpg" alt="webpack"></p><p>随着项目复杂度的提升，控制页面的样式也很多；如果按照这样写法，页面会有一大段来控制样式，考虑到对后期的性能优化不友好，可以考虑把样式单独打包一个文件。</p><p>②、提取 CSS</p><p>新版本 <code>Webpack4.x</code> 建议使用 <code>mini-css-extract-plugin</code>。</p><p>在 <code>npm</code> 官网搜索该插件，点击名称进去查看安装手册，在终端执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ cnpm install --save-dev mini-css-extract-plugin</span><br></pre></td></tr></table></figure><p>安装完该插件后，在根目录 <code>package.json</code> 中的 <code>devDependencies</code> 里能看到该插件和该插件的版本。</p><p>在 <code>webpack.config.js</code> 中的 <code>module</code> 选项和 <code>plugin</code> 选项中配置该插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">const MiniCssExtractPlugin = require(&apos;mini-css-extract-plugin&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // ...</span><br><span class="line">    module: &#123;</span><br><span class="line">      rules: [</span><br><span class="line">        &#123;</span><br><span class="line">          test: /\.css$/,</span><br><span class="line">          use: [ </span><br><span class="line">            &#123; loader: &quot;style-loader&quot; &#125;,  </span><br><span class="line">            &#123;</span><br><span class="line">                loader: MiniCssExtractPlugin.loader,</span><br><span class="line">                options: &#123;</span><br><span class="line">                  esModule: true,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">            &apos;css-loader&apos;,</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">      new HtmlWebpackPlugin(&#123;</span><br><span class="line">        title: &apos;学习webpack&apos;</span><br><span class="line">      &#125;),</span><br><span class="line">      new MiniCssExtractPlugin(&#123; </span><br><span class="line">        filename: &apos;style.css&apos;</span><br><span class="line">      &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在终端执行 <code>cnpm start</code> 打包完成后，在浏览器上运行 <code>index.html</code>，可以看到与之前效果一样；使用开发者工具能看到生成的样式文件 <code>style.css</code>，之前嵌套在页面中的样式不见了。</p><p>效果如下：</p><p><img src="webpack1-3.jpg" alt="webpack"></p><p>大型项目中一般会选择应用预编译语言，这里使用 <code>Sass</code> 预编译语言。</p><p>在 <code>nmp</code> 官网搜索该 <code>loader</code>，点击名称进去查看使用安装手册，在终端执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ cnpm install --save-dev sass-loader node-sass</span><br></pre></td></tr></table></figure><p>安装完毕后，在根目录 <code>package.json</code> 中的 <code>devDependencies</code> 里能看到该 <code>loader</code> 和该 <code>loader</code> 的版本。</p><p>在 <code>webpack.config.js</code> 中的 <code>module</code> 选项中配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // ...</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      // ...</span><br><span class="line">        &#123;</span><br><span class="line">            test: /\.s[ac]ss$/i,</span><br><span class="line">            use: [</span><br><span class="line">              // Creates `style` nodes from JS strings</span><br><span class="line">              &apos;style-loader&apos;,</span><br><span class="line">              // Translates CSS into CommonJS</span><br><span class="line">              &apos;css-loader&apos;,</span><br><span class="line">              // Compiles Sass to CSS</span><br><span class="line">              &apos;sass-loader&apos;,</span><br><span class="line">            ],</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样在根目录 <code>src</code> 下创建一个专门存放 <code>sass</code> 样式文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// index.scss</span><br><span class="line">$fontSize: 16px;</span><br><span class="line">body&#123; font-size:$fontSize;&#125;</span><br></pre></td></tr></table></figure><p>在根目录 <code>src/index.js</code> 中引入该 <code>scss</code> 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">document.write(&apos;hello webpack&apos;) </span><br><span class="line">require(&apos;./style.css&apos;)</span><br><span class="line">require(&apos;./index.scss&apos;)</span><br></pre></td></tr></table></figure><p>在终端执行 <code>cnpm start</code> 打包完成后，在浏览器上运行 <code>index.html</code>，能看到页面字体变化。</p><p>③、打包图片</p><p>打包处理图片使用 <code>url-loader</code> 和 <code>file-loader</code>。</p><p>在 <code>npm</code> 官网搜索该 <code>loader</code>，点击名称进去查看安装手册，在终端执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ cnpm install url-loader file-loader --save-dev</span><br></pre></td></tr></table></figure><p>安装完该插件后，在根目录 <code>package.json</code> 中的 <code>devDependencies</code> 里能看到该 <code>loader</code> 和该 <code>loader</code> 的版本。</p><p>在 <code>webpack.config.js</code> 中的 <code>module</code> 选项中配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  // ...</span><br><span class="line">    module: &#123;</span><br><span class="line">      rules: [</span><br><span class="line">       // ...</span><br><span class="line">        &#123;</span><br><span class="line">            test: /\.(png|jpe?g|gif)$/i,</span><br><span class="line">            loader: &apos;file-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">                outputPath: &apos;images&apos;,</span><br><span class="line">                name: &apos;[1]-[name].[ext]&apos;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">  &#125;,</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>style.css</code> 样式文件中引入一张图片作为背景图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*&#123; margin:0px;padding:0px;&#125;</span><br><span class="line">body&#123; background-color: red; &#125;</span><br><span class="line">body&#123; background: url(&apos;./webpack1-3.jpg&apos;) repeat-x; &#125;</span><br></pre></td></tr></table></figure><p>在终端执行 <code>cnpm start</code> 打包完成后，在浏览器上运行 <code>index.html</code>，能看到之前的背景色被改变了。</p><p>技术不断创新，前端技术领域也是如此。新项目中越来越喜欢使用 <code>ES6</code> 作为处理 <code>JS</code> 页面数据交互，接下来继续打包 <code>ES6</code>。</p><p>④、打包 ES6</p><p>打包处理 <code>ES6</code> 使用 <code>babel-loader</code>、<code>babel-core</code>、<code>babel-preset-env</code>、<code>babel-preset-es2015</code>。</p><p>在 <code>npm</code> 官网搜索该 <code>loader</code>，点击名称金进去查看安装手册，在终端执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cnpm i babel-loader babel-core babel-preset-env babel-preset-es2015 --save-dev</span><br></pre></td></tr></table></figure><p>附：如果运行出错可以安装：<code>@babel/core</code>，<code>@babel/preset-env</code>；其中<code>babel-loader</code> 转换 <code>js</code> 加载器；<code>@babel/core</code> 为 <code>babel</code> 的核心模块；<code>@babel/preser-env</code> 将 <code>ES6</code> 转为 <code>ES5</code>；<code>babel-preset-es2015</code>将部分 <code>ES6</code> 转化成 <code>ES5</code> 语法。</p><p>安装完该插件后，在根目录 <code>package.json</code> 中的 <code>devDependencies</code> 里能看到该 <code>loader</code> 和该 <code>loader</code> 的版本。</p><p>在 <code>webpack.config.js</code> 中的 <code>module</code> 选项中配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  // ...</span><br><span class="line">    module: &#123;</span><br><span class="line">      rules: [</span><br><span class="line">       // ...</span><br><span class="line">        &#123;</span><br><span class="line">            test: /\.m?js$/,</span><br><span class="line">            exclude: /(node_modules|bower_components)/,</span><br><span class="line">            use: &#123;</span><br><span class="line">              loader: &apos;babel-loader&apos;,</span><br><span class="line">              options: &#123;</span><br><span class="line">                  presets: [&apos;@babel/preset-env&apos;]</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">  &#125;,</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>项目中处理页面数据交互一般都是存放单独脚本文件，因此在根目录下中的 <code>src</code> 目录下创建一个脚本文件 <code>es6.js</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let today = &apos;今天天气很好&apos;;</span><br><span class="line">alert(today);</span><br></pre></td></tr></table></figure><p>在根目录 <code>src/index.js</code> 中引入该脚本文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">document.write(&apos;hello webpack&apos;) </span><br><span class="line">require(&apos;./style.css&apos;)</span><br><span class="line">require(&apos;./es6.js&apos;)</span><br></pre></td></tr></table></figure><p>此时运行 <code>cnpm install</code> 肯定会报错，因为需要设置 <code>babel</code>。在根目录下创建 <code>.babelre</code> 大致内容大致如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &apos;presets&apos;:[&apos;env&apos;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时在终端执行 <code>cnpm start</code> 打包完成后，在浏览器上运行 <code>index.html</code>，能看到页面弹出的语句。</p><p>目前为止打包生成的 <code>index.html</code> 模版每次都得重新刷新页面。为了提高开发效率 <code>Webpack</code> 提供了开启服务热更新替换，不用刷新界面就能实现热更新。下面实现自动开启服务热更新。</p><h3 id="devServer"><a href="#devServer" class="headerlink" title="devServer"></a>devServer</h3><p>查看 <code>Webpack</code> 手册安装相关模块，在终端执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ cnpm i --save-dev webpack-dev-server</span><br></pre></td></tr></table></figure><p>安装成功后，在根目录 <code>package.json</code> 中的 <code>devDependencies</code> 里能看到 <code>dev-server</code> 和 <code>dev-server</code> 的版本</p><p>在 <code>webpack.config.js</code> 中配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">  const webpack = require(&apos;webpack&apos;)</span><br><span class="line"></span><br><span class="line">  module.exports = &#123;</span><br><span class="line">   // ...</span><br><span class="line">    devServer: &#123;</span><br><span class="line">      contentBase:path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">      host: &apos;localhost&apos;,</span><br><span class="line">      port:8090,</span><br><span class="line">      open: true,  // 自动打开浏览器</span><br><span class="line">      hot: true  // 热更新</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>修改 <code>package.json</code> 文件中的 <code>scripts</code> 字段里面的 <code>start</code> 属性对应的属性值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line"> &quot;scripts&quot;: &#123;</span><br><span class="line">   &quot;start&quot;: &quot;webpack-dev-server&quot;,</span><br><span class="line">   &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line"> &#125;,</span><br><span class="line"> // ...</span><br></pre></td></tr></table></figure><p>也可以添加新的自定义启动 <code>Webpack</code> 命令，如 <code>run</code> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;webpack&quot;,</span><br><span class="line">    &quot;run&quot;: &quot;webpack-dev-server&quot;,</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  // ...</span><br></pre></td></tr></table></figure><p>在终端执行 <code>cnpm start</code> 或者 <code>cnpm run</code> 会看到浏览器自动打开生成的 <code>index.html</code>。然后在 <code>styl.css</code> 中添加样式，如：<code>font-size:30px</code> 页面会自动更新并显示最新内容。</p><p>项目中或许会用到 <code>jQuery</code> 库或者 <code>Vue</code>，那么如何使用呢？继续往下看。</p><h3 id="快捷导入"><a href="#快捷导入" class="headerlink" title="快捷导入"></a>快捷导入</h3><p>首先在 <code>npm</code> 官网查询要安装的包，如 <code>jQuery</code>，在终端执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ cnpm install --save-dev jquery</span><br></pre></td></tr></table></figure><p>安装完毕之后，在根目录 <code>package.json</code> 中的 <code>devDependencies</code> 里能看到 <code>jQuery</code> 和 <code>jQuery</code> 的版本。</p><p>在 <code>webpack.config.js</code> 中的 <code>plugins</code> 选项中配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">modules.exports = &#123;</span><br><span class="line">  // ...</span><br><span class="line">  plugins: [</span><br><span class="line">    // ...</span><br><span class="line">      new webpack.ProvidePlugin(&#123;</span><br><span class="line">      $: &apos;jquery&apos;,</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了方便看效果，在根目录下的 <code>src</code> 中创建新的文件，如：<code>es5.js</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// es5.js</span><br><span class="line">$(&apos;body&apos;).text(&apos;Hello World!!!&apos;)</span><br></pre></td></tr></table></figure><p>在根目录 <code>src/index.js</code> 中引入该脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">document.write(&apos;hello webpack&apos;) </span><br><span class="line">require(&apos;./style.css&apos;)</span><br><span class="line">require(&apos;./es6.js&apos;)</span><br><span class="line">require(&apos;./es5.js&apos;)</span><br></pre></td></tr></table></figure><p>这时在页面上能看到 <code>Hello World!!!</code> 字样。到此为止一个入门级带有热更新的 <code>Webpack</code> 学习完毕。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>到这里入门级 <code>Webpack</code> 就算结束了。以上内容从认识 <code>Webpack</code> 到使用各种 <code>loader</code> 和各种 <code>plugins</code> 打包生成资源应用在项目中，认识了基本的使用语法和应用各种配置，也为以后进阶的学习夯实基础。</p><p>针对不同的项目，还有更多的 <code>Webpack</code> 打包细节需要调优，如：如何减少搜索文件；如何提高 <code>loader</code> 的打包速度；如何排除项目中无用的打包文件等等。在接下来的时间里，慢慢研究与学习。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;前端构建工具 &lt;code&gt;Webpack&lt;/code&gt; 最近特火，火到 &lt;code&gt;Vue&lt;/code&gt;/&lt;code&gt;React&lt;/code
      
    
    </summary>
    
    
      <category term="Webpack" scheme="http://blog.yuanbeauty.com/categories/Webpack/"/>
    
      <category term="入门 Webpack" scheme="http://blog.yuanbeauty.com/categories/Webpack/%E5%85%A5%E9%97%A8-Webpack/"/>
    
    
  </entry>
  
  <entry>
    <title>Git 创建多账号</title>
    <link href="http://blog.yuanbeauty.com/archives/aff47974.html"/>
    <id>http://blog.yuanbeauty.com/archives/aff47974.html</id>
    <published>2020-01-03T16:00:00.000Z</published>
    <updated>2020-01-03T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>使用 <code>Git</code> 过程中，难免会遇到使用 <code>Git</code> 既管理公司项目，又要管理自己个人项目。那么 <code>Git</code> 如何做到呢？是本篇主要讨论的内容，在这里做下笔记。</p><h3 id="生成新-ssh-key"><a href="#生成新-ssh-key" class="headerlink" title="生成新 ssh key"></a>生成新 ssh key</h3><p>确保已经安装了 <code>Git</code>，在电脑上打开 <code>Git</code> 创建 <code>ssh key</code>。如果已经存在一个 <code>ssh key</code> 那么需要生成第二个 <code>ssh key</code>，使用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygn -t rsa -C &quot;email&quot;</span><br></pre></td></tr></table></figure><p>为了与之前的 <code>ssh</code> 区分，可以重新命名以 <code>id_rsa_me</code> 重新命名。回车，重复确认回车即可。</p><h3 id="添加新-ssh-key"><a href="#添加新-ssh-key" class="headerlink" title="添加新 ssh key"></a>添加新 ssh key</h3><p>默认 <code>ssh</code> 只会读取 <code>id_rsa</code>，所以为了让 <code>ssh</code> 识别新的私钥，需要将其添加到 <code>ssh agent</code>。</p><p>使用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add ~/.ssh/id_rsa_me</span><br></pre></td></tr></table></figure><p>如果报错 <code>Could not open a connection to your authentication agent.</code>无法连接到 <code>ssh agent</code> 可执行 <code>ssh-agent bash</code> 命令后再执行 <code>ssh-add</code> 命令。</p><p>然后将公钥添加到 <code>Git</code> 帐号。</p><h3 id="配置-config-文件"><a href="#配置-config-文件" class="headerlink" title="配置 config 文件"></a>配置 config 文件</h3><p>查看 <code>.ssh</code> 文件中是否存在 <code>config</code> 文件。</p><p>如果存在，可以直接编辑 <code>config</code> 文件。可以使用 <code>Sublime Text</code> 编辑器进行编辑。</p><p>如果不存在，需要创建 <code>config</code> 文件，使用 <code>touch config</code> 命令创建，然后再编辑 <code>config</code> 文件。</p><p>对 <code>config</code> 文件进行配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 第一个账号</span><br><span class="line">Host xxx.com</span><br><span class="line">    HostName xxx.com</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa</span><br><span class="line"></span><br><span class="line"># 第二个账号</span><br><span class="line">Host github.com</span><br><span class="line">    HostName github.com</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa_me</span><br></pre></td></tr></table></figure><h3 id="测试是否配置成功"><a href="#测试是否配置成功" class="headerlink" title="测试是否配置成功"></a>测试是否配置成功</h3><p>使用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ssh -T git@zc</span><br></pre></td></tr></table></figure><p>如果出现欢迎语，则表示配置成功。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>创建 <code>Git</code> 多账号时，注意创建新的 <code>ssh key</code> 与默认 <code>ssh key</code> 区分，再创建 <code>config</code> 文件进行配置帐号进行管理。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;使用 &lt;code&gt;Git&lt;/code&gt; 过程中，难免会遇到使用 &lt;code&gt;Git&lt;/code&gt; 既管理公司项目，又要管理自己个人项目。那么
      
    
    </summary>
    
    
      <category term="Git" scheme="http://blog.yuanbeauty.com/categories/Git/"/>
    
      <category term="创建多帐号" scheme="http://blog.yuanbeauty.com/categories/Git/%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%B8%90%E5%8F%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>总结Vue使用技巧</title>
    <link href="http://blog.yuanbeauty.com/archives/efcc221b.html"/>
    <id>http://blog.yuanbeauty.com/archives/efcc221b.html</id>
    <published>2019-11-09T16:00:00.000Z</published>
    <updated>2019-11-09T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言：</strong></p><p>Vue3.x版本已经在路上，在到来之前总结Vue2.x版本开发经验，趁机打好Vue2.x版本基础，本文列举以下开发技巧：</p><h3 id="导入组件"><a href="#导入组件" class="headerlink" title="导入组件"></a>导入组件</h3><p>原始写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import ChapterTitle from &apos;@/components/list/ChapterTitleCom&apos; </span><br><span class="line">import CourseList from &apos;@/components/list/CourseListCom&apos;</span><br><span class="line">export default &#123;</span><br><span class="line">  // ...略</span><br><span class="line">  components: &#123; ChapterTitle, CourseList &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>避免写重复代码，可以参考webpack官网使用require.context写法；无论有多少文件，都能引入使用。</p><p>官网例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require.context(&apos;./test&apos;, false, /\.js$/)</span><br></pre></td></tr></table></figure></p><p>require.context函数接受三个参数</p><ul><li>读取文件路径</li><li>是否遍历文件子目录</li><li>匹配文件的正则</li></ul><p>结合前端工程化，可以应用在Vue引入组件情景<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">const files = require.context(&apos;@/components/list&apos;, false, /\.vue$/)</span><br><span class="line">const modules = &#123;&#125;</span><br><span class="line">files.keys().forEach(key =&gt; &#123;</span><br><span class="line">  const path = path.basename(key, &apos;.vue&apos;)</span><br><span class="line">  modules[path] = files(key).default || files(key)</span><br><span class="line">&#125;)</span><br><span class="line">components: modules</span><br></pre></td></tr></table></figure></p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ul><li><p>beforeCreate 创建之前，在实例化之后，数据观测与事件配置之前被调用。</p></li><li><p>created 创建之后，在实例化完成后被调用。实例化已经完成相关配置，如：数据观测属性和方法运算，事件回调。此时$el属性不可见，挂载阶段没开始，一般在该周期发起ajax请求。</p></li><li><p>beforeMounted 挂载前，准备挂载阶段。模版在内存中编译完成，没有真正渲染到DOM页面，页面看不到真实数据。</p></li><li><p>mounted 挂载成功。$el被创建的vm.$el替换，此时页面已经真正渲染好，可以看到真实数据。</p></li><li><p>beforeUpdate 数据更新时调用。拿到最新data，在内存中重新渲染一颗新的DOM树，还没有挂载到页面，此时页面呈现的是旧数据。</p></li><li><p>updated 页面DOM已更新完毕，data中数据是最新的，页面呈现数据是最新data。</p></li><li><p>beforeDestory 实例销毁之前调用，此时组件还没销毁，能正常使用。如data，methods还能访问；该周期在服务端渲染期间不被调用。</p></li><li><p>destory 实例销毁之后，组件已完成销毁。如：此时data，methods都不可用。 </p></li></ul><h3 id="data"><a href="#data" class="headerlink" title="data"></a>data</h3><p>可以存放各种数据类型；在数据变化时，相关视图用到的数据同步更新；data称为动态数据，任何情况下，都可以修改数据类型和数据结构。</p><p>代码片段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default() &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      str: &apos;vue&apos;,</span><br><span class="line">      num: 6,</span><br><span class="line">      bol: true,</span><br><span class="line">      obj: &#123;</span><br><span class="line">        name: &apos;js&apos;</span><br><span class="line">      &#125;,</span><br><span class="line">      fn: function() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/scritp&gt;</span><br></pre></td></tr></table></figure></p><h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p>Vue提供了侦听属性watch，使用通用方式观察和响应Vue实例数据变化，watch可以执行ajax异步获取数据，操作DOM等任何逻辑。</p><p>用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123; a &#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;button @click=&quot;() =&gt; (a += 1)&quot;&gt;click me&lt;/button&gt; </span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123; </span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123; </span><br><span class="line">      a: 1, </span><br><span class="line">      obj: &#123;</span><br><span class="line">        b: 2</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    a: function(oldVal, newVal) &#123;</span><br><span class="line">      console.log(oldVal, newVal)</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;obj.b&apos;: function(oldVal, newVal) &#123;  </span><br><span class="line">      console.log(oldVal, newVal) </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>实际遇到场景：组件创建时候初始化加载查询接口；监听input框，当input值发生变化时候重新加载筛选后的列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  created: &#123;</span><br><span class="line">    this.getCourseList()</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    inptVal: &#123;</span><br><span class="line">      this.getCourseList() </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>使用watch提供的immediate与handler简写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  watch: &#123;</span><br><span class="line">    inpt: &#123;</span><br><span class="line">      handler: &apos;getCourseList&apos;,</span><br><span class="line">      immediate: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>声明<strong>immediate:true 表示创建组件时立马执行一次</strong>。</p><p>利用watch提供deep属性，深度监听复杂数据类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123; obj.a&#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;button @click=&quot;() =&gt; (obj.a += 1)&quot;&gt;click me&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;  </span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;  </span><br><span class="line">      obj: &#123; </span><br><span class="line">        a: 1</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    obj: &#123; </span><br><span class="line">      handler: function(oldVal, newVal) &#123;</span><br><span class="line">        console.log(oldVal, newVal)</span><br><span class="line">      &#125;,</span><br><span class="line">      deep: true,</span><br><span class="line">      immediate: true</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>如果修改对象obj中a属性的值，不添加deep:true，只能监听对象obj的改变，不会触发回调。</p><h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><p>计算属性自动监听依赖值的变化，在监听值的变化时，触发一个回调；它有以下几点：</p><ul><li>数据是响应式</li><li>可以进行数据逻辑处理，减少模版中计算逻辑</li><li>可以对计算属性中的数据监听</li></ul><p>computed由两部分组成get和set，默认只有get，set需要手动添加，set不是直接修改计算属性，是修改它的依赖。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line"> fullName: &#123;</span><br><span class="line">   get: function() &#123;</span><br><span class="line">      return this.firstName + &apos;--&apos; + this.lastName</span><br><span class="line">   &#125;,</span><br><span class="line">   set:function(newVal) &#123;</span><br><span class="line">      // this.firstName = newVal; // 抛出error</span><br><span class="line">      var name = newVal.split(&apos;--&apos;);</span><br><span class="line">      this.firstName = name[0]; // 对它的依赖赋值</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>计算属性与普通属性区别:<br>计算属性可以像普通属性一样在模版中绑定计算属性，并且计算属性值是一个函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    msg: function() &#123;</span><br><span class="line">      return &apos;vue&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>计算属性与方法区别:<br><strong>computed可以缓存，只要相关依赖值没有发生变化，计算属性得到的值是之前缓存计算结果，不会多次执行</strong>；从上述代码发现必须要有return返回值；methods不能缓存。</p><p>除此之外，computed不能执行异步任务，计算属性必须是同步执行；watch同步与异步都可以操作，并且没有return。可以总结为computed能做的，watch都能做，反之不可以。</p><h3 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h3><p>组件实例作用域相互独立，不同组件之间的数据无法相互引用，针对不同场景使用不同组件传值方式。</p><ul><li>父组件向子组件传值</li></ul><p>父组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;List :list=&quot;list&quot;&gt;&lt;/List&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import List from &apos;@components/List&apos;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;App&apos;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">       list: [&apos;小社区&apos;, &apos;社区&apos;, &apos;大社区&apos;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    List </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>子组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;ul&gt;</span><br><span class="line">    &lt;li v-for=&quot;(item, index)in list&quot; :key=&quot;index&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;List&apos;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    list: &#123;</span><br><span class="line">      type: Array,</span><br><span class="line">      required: true </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>在子组件接收props支持数组和对象形式，<strong>推荐使用对象形式更严谨</strong>。其中type值可为：string/number/boolean/function/object/Symbol；</p><p>required:true 表示是否必传。</p><p>props在数据传递时不能修改它的数据类型，而且在子组件不允许直接操作传递过来的props，可通过其它方式简介修改，如：使用computed计算属性；也可以在组件data中重新定义。</p><p>父组件向子组件传递数据，组件中的数据有三种形式：data/props/computed。</p><h3 id="子组件向父组件传值"><a href="#子组件向父组件传值" class="headerlink" title="子组件向父组件传值"></a>子组件向父组件传值</h3><p>父组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;List :list=&quot;list&quot; @updateName=&quot;getName&quot;&gt;&lt;/List&gt;  </span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import List from &apos;@components/List&apos;</span><br><span class="line"> export default &#123;</span><br><span class="line">    methdds: &#123;</span><br><span class="line">      getName: function(name) &#123;</span><br><span class="line">         console.log(name)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      List</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>子组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li v-for=&quot;(item, index)&quot;</span><br><span class="line">       :key=&quot;index&quot; </span><br><span class="line">       @click=&quot;getMyName(item)&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getMyName: function(name) &#123;</span><br><span class="line">      this.$emit(&apos;updateName&apos;, name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h3 id="emit与-on"><a href="#emit与-on" class="headerlink" title="$emit与$on"></a>$emit与$on</h3><p>声明一个全局Vue实例变量把所有通信数据，事件监听都存储到这个变量，实现任何组件间的通信，包括跨级、父子、兄弟；这种方式推荐小项目。</p><p>实现原理：使用$emit和$on并实例化一个全局Vue实现数据共享。</p><p>main.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export default Bus = new Vue()</span><br></pre></td></tr></table></figure></p><p>组件B<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button</span><br><span class="line">     @click=&quot;sendC&quot;&gt;</span><br><span class="line">     click me</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Bus from &apos;main&apos;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    sendC: function() &#123;</span><br><span class="line">      Bus.$emit(&apos;msg&apos;, &apos;来自组件B&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>组件C<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import Bus from &apos;main&apos;</span><br><span class="line">export default&#123;</span><br><span class="line">  mounted: &#123;</span><br><span class="line">    this.getVal();</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getVal: function() &#123;</span><br><span class="line">      Bus.$on(&apos;msg&apos;, msg=&gt; &#123;</span><br><span class="line">        console.log(msg);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h3 id="attrs"><a href="#attrs" class="headerlink" title="$attrs"></a>$attrs</h3><p>包含父作用域中不被prop所识别的特征绑定(class和style除外)。当一个组件没有声明任何prop时，这里包含所有父作用域的绑定(class和style除外)，并且可以通过v-bind=”$attrs”传入组件内部。</p><p>父组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">     &lt;Child </span><br><span class="line">        name=&quot;name&quot; </span><br><span class="line">        age=&quot;age&quot; </span><br><span class="line">        height=&quot;height&quot;</span><br><span class="line">        title=&quot;web&quot;&gt;</span><br><span class="line">     &lt;/Child&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"> import Child from &apos;@/components/Child&apos;</span><br><span class="line"> export default &#123;</span><br><span class="line">   data() &#123;</span><br><span class="line">     return &#123;</span><br><span class="line">       name: &apos;vue&apos;,</span><br><span class="line">       age: 6,</span><br><span class="line">       height: 180</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>子组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"> export default &#123;</span><br><span class="line">   inheritAttrs: false,</span><br><span class="line">   props: &#123;</span><br><span class="line">     height: String,</span><br><span class="line">     default: &apos;&apos;</span><br><span class="line">   &#125;,</span><br><span class="line">   mounted() &#123;</span><br><span class="line">     console.log(this.$attrs);</span><br><span class="line">      // &#123; name: &quot;vue&quot;, age: 6, title: &apos;web&apos; &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>inheritAttrs默认值为true，设置false就隐藏，关闭自动挂载到组件根元素上的没有在props声明的属性。$attrs就是剔除被props定义的属性。</p><h3 id="listeners"><a href="#listeners" class="headerlink" title="$listeners"></a>$listeners</h3><p>包含父作用域中(不含.navtive修饰符)v-on事件监听器，</p><p>父组件方法可以通过v-on=”$listeners”传入内部组件。在创建更高层次的组件时非常有用。</p><p>场景：子组件需要调用父组件的方法</p><p>父组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Parent @change=&quot;change&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p>子组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  mounted: &#123;</span><br><span class="line">     console.log(this.$listeners) // 拿到 change事件</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h3 id="provide与inject"><a href="#provide与inject" class="headerlink" title="provide与inject"></a>provide与inject</h3><p>这对选项需要一起使用，主要为高阶插件和组件库提供。不推荐直接应用在程序中。以允许一个祖先组件向其所有子孙后代注入一个依赖，不论层次有多深，并在起上下有关系成立的时间里始终生效。</p><p>父组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  provide: &#123; // provide是一个对象 </span><br><span class="line">    bar: &apos;这是父&apos;,</span><br><span class="line">    fn: () =&gt; &#123;</span><br><span class="line">      console.log(&apos;函数被调用&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>子或者孙子组件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  inject: [&apos;bar&apos;, &apos;fn&apos;] // 对象 数组注入到子或孙子组件</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    console.log(this.bar);</span><br><span class="line">    this.fn();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>pronide与inject绑定并不是可响应的。这是官方刻意为之的。如果传入一个可监听对象，那么其对象的属性还是可响应的。</p><p>父组件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  provide: &#123;</span><br><span class="line">    bar: &apos;这是父&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    this.bar = &apos;这是子&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>子或孙子组件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  inject: [&apos;bar&apos;],</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    console.log(this.bar); // 这是父</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h3 id="parent"><a href="#parent" class="headerlink" title="$parent"></a>$parent</h3><p>父组件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    console.log(this.$children)</span><br><span class="line">    // 能拿到一级子组件的属性和方法</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h3 id="children"><a href="#children" class="headerlink" title="$children"></a>$children</h3><p>子组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">   mounted() &#123;</span><br><span class="line">     console.log(this.parent)</span><br><span class="line">     // 可以拿到一级父组件的属性和方法</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p><strong>$parent和$children并不保证顺序，又不是响应式的</strong>。</p><h3 id="refs"><a href="#refs" class="headerlink" title="$refs"></a>$refs</h3><p><strong>ref用在普通DOM元素上，指向就是DOM元素；用在子组件，指向组件实例</strong></p><p>父组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;Child ref=&quot;child&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Child from &apos;@/components/Child&apos;</span><br><span class="line">export default &#123;</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    const child = this.$refs.child;</span><br><span class="line">    console.log(child.name)  // vue</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>子组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line"> data() &#123;</span><br><span class="line">   return &#123;</span><br><span class="line">     name: &apos;vue&apos;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h3 id="root"><a href="#root" class="headerlink" title="$root"></a>$root</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    console.log(this.$root) // 根实例</span><br><span class="line">    console.log(this.$root.$children[0]) // 根实例的一级子组件</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><ul><li>.sync </li></ul><p>父组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Parent :msg.sync=&quot;title&quot; /&gt;</span><br><span class="line">// 编译时扩展如下：</span><br><span class="line">&lt;Parent :msg=&quot;msg&quot; @update.msg=&quot;val =&gt; msg = val&quot;&gt;</span><br></pre></td></tr></table></figure><p>子组件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    this.$emit(&apos;update:msg&apos;, &apos;新的msg&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>自定义事件添加原生click事件，使用native修饰符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;component @click.native=&quot;xxx&quot;&gt;&lt;/component&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><ul><li>.lazy<br>默认情况下，v-model在每一次input事件触发后将输入的值与数据同步。可以使用lazy修饰符，转变使用change事件同步，输入完内容后，光标离开才更新视图。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; v-model.lazy=&quot;xxx&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><ul><li>.number<br>输入的值转化为数值类型。如果先输入的是数字，会限制输入的只能是数字，视图上只显示数字；如果先输入的是字母，相当于没有添加number修饰符，输入什么视图显示什么。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; v-model.number=&quot;xxx&quot; /&gt; </span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><ul><li>.trim<br>过滤input输入内容前后空格，中间空格不过滤。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; v-model.trim=&quot;xxx&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><ul><li>.stop<br>一键阻止事件冒泡，相当于event.stopPropagetion()</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div @click.stop=&quot;func&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><ul><li>.prevent<br>阻止事件的默认行为，相当于event.preventDefault()</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt; </span><br><span class="line">  &lt;form v-on:submit.prevent=&quot;func&quot;&gt;&lt;/form&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>@click.prevent.self会阻止所有点击；@click.self.prevent只会阻止元素自身的点击。</p><ul><li>.self<br>当事件是从事件绑定的元素本身触发回调。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div @click.self=&quot;parent&quot;&gt;</span><br><span class="line">    &lt;div @click.self=&quot;child&quot;&gt;&lt;/div&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><ul><li>.once<br>只能用一次，数据发生变化也不会改变；绑定事件以后只能触发一次</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;button @click.once=&quot;func&quot;&gt;&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><ul><li><p>.capture<br>完整的事件机制：捕获阶段-&gt;目标阶段-&gt;冒泡节点。添加capture就反过来，事件触发从包含这个元素顶层开始往下传播。</p></li><li><p>config.keyCodes自定义按键修饰符别名</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">Vue.config.keyCodes.f1 = func;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="v-slot"><a href="#v-slot" class="headerlink" title="v-slot"></a>v-slot</h3><p>简称插槽，作用是将父组件的template传入子组件。插槽有匿名插槽和作用域插槽。</p><p>匿名插槽<br>父组件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Parent&gt;</span><br><span class="line">  &lt;template v-slot:default&gt;</span><br><span class="line">    任意内容</span><br><span class="line">    &lt;p&gt;这里是匿名插槽&lt;/p&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/Parent&gt;</span><br></pre></td></tr></table></figure></p><p>子组件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;slot&gt;插槽默认值&lt;/slot&gt;</span><br></pre></td></tr></table></figure></p><p>具名插槽，相对匿名插槽组件slot带有name名称<br>父组件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Parent&gt;</span><br><span class="line">  &lt;template v-slot:child&gt;</span><br><span class="line">    任意内容</span><br><span class="line">    &lt;p&gt;这里是具名插槽&lt;/p&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/Parent&gt;</span><br></pre></td></tr></table></figure></p><p>子组件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;slot name=&quot;child&quot;&gt;这是子插槽&lt;/slot&gt;</span><br></pre></td></tr></table></figure></p><ul><li>作用域插槽<br>子组件中的数据可以被父组件拿到</li></ul><p>父组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Parent&gt;</span><br><span class="line"> &lt;template v-slot:child=&quot;slotData&quot;&gt;</span><br><span class="line">     &#123;&#123; slotData.msg &#125;&#125;</span><br><span class="line"> &lt;/template&gt;</span><br><span class="line">&lt;/Parent&gt;</span><br></pre></td></tr></table></figure><p>slotData可以是任意名称，接收是子组件标签slot上属性数据</p><p>子组件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;slot name=&quot;child&quot; :msg=&quot;msg&quot;&gt;</span><br><span class="line">    &#123;&#123; msg &#125;&#125;</span><br><span class="line">&lt;slot&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">data() &#123;</span><br><span class="line">     return &#123;</span><br><span class="line">     msg: &apos;插槽&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;script&gt;</span><br></pre></td></tr></table></figure></p><p>msg是默认数据，在父组件没有v-slot:child=”slotData”时填充。</p><h3 id="filters过滤器"><a href="#filters过滤器" class="headerlink" title="filters过滤器"></a>filters过滤器</h3><p>可用于常见的文本数据进行格式化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;&#123;&#123; msg| upperCase(true) &#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">filters: &#123;</span><br><span class="line">      upperCase: function(val, bol) &#123;</span><br><span class="line">       const str = val.toString();</span><br><span class="line">       if(!!bol) &#123;</span><br><span class="line">          return val.charAt(0).toUpperCase() + val.slice(1)</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        return str.toUpperCase()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h3 id="v-if与v-show"><a href="#v-if与v-show" class="headerlink" title="v-if与v-show"></a>v-if与v-show</h3><p>v-if 根据条件为false时，不存在DOM；在切换过程中，需要经过销毁和重建，开销高。<br>v-show 一直存在DOM中，使用CSS的display属性控制，开销小。</p><h3 id="Vue-set"><a href="#Vue-set" class="headerlink" title="Vue.set"></a>Vue.set</h3><p>额外添加数据有可能不是响应式数据，使用set加入Vue响应式中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.set(目标对象, 目标对象属性, 目标对象属性值)</span><br></pre></td></tr></table></figure></p><h3 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h3><p>用来对组件进行缓存，节省性能。由于是一个抽象组件，在页面渲染完毕后不会被渲染成一个DOM元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">  &lt;Child&gt;&lt;/Child&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure></p><p>在组件切换时，activated/deactivated钩子函数会被执行，被包裹在kepp-alive中的组件状态，会被保留。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;前言：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Vue3.x版本已经在路上，在到来之前总结Vue2.x版本开发经验，趁机打好Vue2.x版本基础，本文列举以下开发技巧：&lt;/p&gt;
&lt;h3 id=&quot;导入组件&quot;&gt;&lt;a href=&quot;#导入组件&quot; class=&quot;headerl
      
    
    </summary>
    
    
      <category term="Vue" scheme="http://blog.yuanbeauty.com/categories/Vue/"/>
    
      <category term="Vue实用技巧" scheme="http://blog.yuanbeauty.com/categories/Vue/Vue%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>JSON.stringify() 妙用</title>
    <link href="http://blog.yuanbeauty.com/archives/85d76abc.html"/>
    <id>http://blog.yuanbeauty.com/archives/85d76abc.html</id>
    <published>2019-06-19T16:00:00.000Z</published>
    <updated>2019-07-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="调试对象"><a href="#调试对象" class="headerlink" title="调试对象"></a>调试对象</h4><p>比如，如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var user = &#123;</span><br><span class="line">name: &apos;hello word&apos;,</span><br><span class="line">age: 18</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.log(user)</span><br></pre></td></tr></table></figure><p>打印输出 <code>[object Object]</code>，因为从对象到字符串的默认转换是 <code>[object Object]</code>。因此，使用 <code>JSON.stringify</code> 先将对象转化字符串，然后把结果输出控制台。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var user = &#123;</span><br><span class="line">name: &apos;hello word&apos;,</span><br><span class="line">age: 18</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.log(JSON.stringify(user))</span><br><span class="line"></span><br><span class="line">// &#123;name:&quot;hello word&quot;, age:18&#125;</span><br></pre></td></tr></table></figure><h4 id="存储-localStorage-对象"><a href="#存储-localStorage-对象" class="headerlink" title="存储 localStorage 对象"></a>存储 localStorage 对象</h4><p>有时想存储创建的对象，并且在浏览器被关闭后让能恢复该对象。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var course = &#123;</span><br><span class="line">name: &apos;三年级语文&apos;,</span><br><span class="line">price: 18</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">localStorage.setItem(&apos;course&apos;, JSON.stringify(course));</span><br><span class="line"></span><br><span class="line">var getLocalCourse = JSON.parse(localStorage.getItem(&apos;course&apos;));</span><br></pre></td></tr></table></figure><h4 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function unique(arr) &#123;</span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line">arr.forEach(function(item) &#123;</span><br><span class="line">var newData = &#123;&#125;;</span><br><span class="line">Object.keys(item).sort().map(function(key) &#123;</span><br><span class="line">newData[key] = item[key];</span><br><span class="line">&#125;)</span><br><span class="line">obj[JSON.stringify(newData)] = item; // 键名不会重复</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">arr = Object.keys(obj).map(function(val) &#123;</span><br><span class="line">return JSON.parse(val);</span><br><span class="line">&#125;)</span><br><span class="line">return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>JSON.stringify</code> 第二个参数可以决定筛选出来的内容，还有第三个参数，可以参考 <code>MDN</code>。</p><h4 id="实现深拷贝"><a href="#实现深拷贝" class="headerlink" title="实现深拷贝"></a>实现深拷贝</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function deepClone(data) &#123;</span><br><span class="line">var _data = JSON.stringify(data);</span><br><span class="line">var newData = JSON.parse(_data);</span><br><span class="line">return newData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断数组是否包含对象，或者对象是否相等"><a href="#判断数组是否包含对象，或者对象是否相等" class="headerlink" title="判断数组是否包含对象，或者对象是否相等"></a>判断数组是否包含对象，或者对象是否相等</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/* 判断数组是否包含某对象 */ </span><br><span class="line"></span><br><span class="line">var data1 = [</span><br><span class="line">&#123; name: &apos;cherry&apos; &#125;,</span><br><span class="line">&#123; name: &apos;sunny&apos; &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">var data2 = &#123; name: &apos;sunny&apos; &#125;;</span><br><span class="line"></span><br><span class="line">console.log(JSON.stringify(data1).indexOf(JSON.stringify(data2)) != -1)</span><br><span class="line">// true</span><br><span class="line"></span><br><span class="line">/* 判断数组或对象是否相等 */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var a = [1, 2, 3];</span><br><span class="line">var b = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">console.log(JSON.stringify(a) == JSON.stringify(b)) </span><br><span class="line">// true</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;调试对象&quot;&gt;&lt;a href=&quot;#调试对象&quot; class=&quot;headerlink&quot; title=&quot;调试对象&quot;&gt;&lt;/a&gt;调试对象&lt;/h4&gt;&lt;p&gt;比如，如下代码：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://blog.yuanbeauty.com/categories/JavaScript/"/>
    
      <category term="JSON.stringify() 妙用" scheme="http://blog.yuanbeauty.com/categories/JavaScript/JSON-stringify-%E5%A6%99%E7%94%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>你不知道的前端安全知识</title>
    <link href="http://blog.yuanbeauty.com/archives/8e8805c.html"/>
    <id>http://blog.yuanbeauty.com/archives/8e8805c.html</id>
    <published>2019-05-02T16:00:00.000Z</published>
    <updated>2019-05-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近线上项目被他人攻击，对网站危害极大。之前对前端安全知识只是大致了解，简单应用。为了更详细的了解与应用前端安全知识，因此查找与前端安全相关材料抱着求学的心态系统地学习前端安全知识，在这里做个简单的总结，希望在日常开发中不断预防和修复漏洞。</p><p>典型的前端安全有XSS攻击和CSRF攻击，本篇主要从这两方面阐述。</p><p><strong>XSS的介绍</strong></p><p>XSS全称Cross-Site Scripting(跨站脚本攻击)，是一种代码注入攻击。攻击者在目标网站上注入恶意脚本，能在用户的浏览器上运行。利用恶意脚本，攻击者可以获取用户敏感信息，如：Cookie等，进行攻击危害数据。</p><h3 id="XSS存在的原因"><a href="#XSS存在的原因" class="headerlink" title="XSS存在的原因"></a>XSS存在的原因</h3><p>在URL参数场景，用户输入提交给服务端的URL内容，没有进行充分的过滤。如果将所有不合法的参数和输入内容做充分的过滤，就不会导致在用户浏览器中执行攻击者的脚本。</p><p>只做URL参数过滤和用户提交内容过滤是不行的。因为攻击者可以使用各种方式绕过服务端的过滤，最典型的是对URL参数进行各种编码，比如: <code>escape/encodeURI/encodeURIComponent</code>/8进制/10进制/16进制绕过过滤。   </p><p><strong>XSS攻击方式</strong></p><p>①、一个搜索页面，点击搜索页面url添加上了关键词，页面显示与关键词相关的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; value=&quot;&lt;%= getParams(keyword)%&gt;&quot; /&gt;</span><br><span class="line">&lt;button&gt;搜索&lt;/button&gt;</span><br><span class="line">&lt;div&gt;显示搜索的内容：&lt;%= getParams(keyword)%&gt; &lt;/div&gt;</span><br></pre></td></tr></table></figure><ul><li>附：文中&lt;%= … %&gt;语法参考EJS语法。</li></ul><p>文本框值没做任何处理，项目就上线了。某天收到一个神秘链接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.xxx.com/search?keyword=&lt;script&gt;alert(&apos;xss&apos;)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>浏览器发送请求<code>http://www.xxx.com/search?keyword=&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;</code>时，后端会解析URL中的请求参数keyword的值，得到<code>&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;</code>，浏览器最终在页面搜索结果区域显示与关键词相关内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;显示搜索的内容：&lt;script&gt;alert(&apos;xss&apos;)&lt;/script&gt; &lt;/div&gt;</span><br></pre></td></tr></table></figure><p>对于<code>&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;</code>浏览器无法分辨是否属于恶意代码，因此会执行脚本。</p><p>对于这种攻击方式，可以告诉浏览器这段内容是文本就可以了。可以选择进行转义字符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; value=&quot;&lt;%= esHTML(getParams(keyword))%&gt;&quot; /&gt;</span><br><span class="line">&lt;button&gt;搜索&lt;/button&gt;</span><br><span class="line">&lt;div&gt;显示搜索的内容：&lt;%= esHTML(getParams(keyword))%&gt; &lt;/div&gt;</span><br></pre></td></tr></table></figure><p>转义规则：</p><table><thead><tr><th>字符</th><th>转义后的字符</th></tr></thead><tbody><tr><td>‘</td><td><code>&amp;#x27;</code></td></tr><tr><td>&amp;</td><td><code>&amp;amp;</code></td></tr><tr><td>&lt;</td><td><code>&amp;lt;</code></td></tr><tr><td>&gt;</td><td><code>&amp;gt;</code></td></tr><tr><td>/</td><td><code>&amp;#x2F;</code></td></tr><tr><td>“</td><td><code>&amp;quot;</code></td></tr></tbody></table><p>经过转义后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; value=&quot;&amp;lt;script&amp;gt;alert(&amp;#x27;xss&amp;#x27;)&amp;lt;script&amp;gt;&quot; /&gt;</span><br><span class="line">&lt;button&gt;搜索&lt;/button&gt;</span><br><span class="line">&lt;div&gt;显示搜索的内容：</span><br><span class="line">  &amp;lt;script&amp;gt;alert(&amp;#x27;xss&amp;#x27;)&amp;lt;script&amp;gt; </span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>通过<strong>转义字符恶意脚本</strong>被转义，浏览器<strong>不会执行</strong>恶意脚本，搜索到的与关键词相关内容也正常在页面中显示出来。有些情况只做HTML转义，并不是高枕无忧，比如下面场景。</p><p>②、超链接场景，页面正常显示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;http://www.xxx.com/search?to=javascript:alert(&apos;xss&apos;);&quot;&gt;click&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>用户一旦进行点击，浏览器就会执行代码；这种场景如果使用上述转义字符规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;http://www.xxx.com/search?to=javascript:alert(&amp;#x27;xss&amp;#x27;);&quot;&gt;click&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>显然是不可行的。因为href跟的是正确属性，浏览器无法分辨属性值是否属于恶意代码，用户点击恶意脚本会执行。</p><p>对于这种形式可以<strong>设置白名单</strong>预防攻击：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var allowHTTP = [&apos;http&apos;, &apos;https&apos;];</span><br><span class="line">var isAllow = isAllowFunc(allowHTTP, to);</span><br><span class="line">if(!!isAllow) &#123;</span><br><span class="line">  &lt;a href=&quot;跳转到相应页面&quot;&gt;...&lt;/a&gt;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">  &lt;a href=&quot;/404.html&quot;&gt;...&lt;/a&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过该方式可知针对超链接跳转方式，如：<code>location.href=&quot;xxx&quot;或者&lt;a href=&quot;xxx&quot;&gt;&lt;/a&gt;；</code>甚至包括<code>&lt;script&gt;，&lt;style&gt;，&lt;img&gt;</code>等标签的src属性值，可以选择白名单校验禁止以<code>javascript:</code>开头的链接 (包括javascript大小写的拼写) 和其他非法的scheme。</p><p>③、有些情况把JSON数据直接写在HTML中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt; var data = data.toJSON(); &lt;/script&gt;</span><br></pre></td></tr></table></figure><p>这种方式JSON也存在风险，并且插入的JSON不能进行转义。因为转义 “ 后JSON格式被破坏。</p><p>因此需要实现一个对JSON数据进行转义的方法。但是需要注意的是：</p><ul><li><p>当JSON中包含U+2028或U+2029这两个字符时，不能作为 JavaScript 的字面量使用，否则会抛出语法错误。</p></li><li><p>当JSON中包含字符串<code>&lt;/script&gt;</code>时，当前的script标签将会被闭合，后面的字符串内容浏览器会按照HTML进行解析；通过增加下一个<code>&lt;script&gt;</code>标签等方法就可以完成注入。</p></li></ul><p>转义规则：</p><table><thead><tr><th>字符</th><th>转义后的字符</th></tr></thead><tbody><tr><td>U+2028</td><td><code>\u2028</code></td></tr><tr><td>U+2029</td><td><code>\u2029</code></td></tr><tr><td>&lt;</td><td><code>\u003c</code></td></tr></tbody></table><p>修改后的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt; var data = esJSON(data.toJSON()); &lt;/script&gt;</span><br></pre></td></tr></table></figure><p>通过以上可知：</p><p>HTML<strong>转义</strong>是<strong>非常复杂</strong>的，在不同的场景要<strong>采用不同的转义规则</strong>。如果采用的方式不正确，很可能埋下XSS隐患。因此尽量避免自己写转义库，<strong>应采用成熟，通用的转义库</strong>。</p><h3 id="归纳注入方式"><a href="#归纳注入方式" class="headerlink" title="归纳注入方式"></a>归纳注入方式</h3><ul><li>在HTML中内嵌恶意内容以script标签形式注入。</li><li>在HTML中拼接的JavaScript数据突破了原本的限制(字符串，变量等)。</li><li>在标签属性中，恶意内容包含引号，突破属性值的限制，注入其他属性或标签。</li><li>在标签style，href，src等属性中，包含JavaScript等可执行代码。</li><li>在onload，onclick等事件中注入不受控制的代码。</li><li>在style属性和标签中，包含background: url(‘JavaScript…’)类似代码。</li><li>在style属性和标签中，包含expression(…)类似CSS表达式代码。</li></ul><h3 id="XSS攻击分类"><a href="#XSS攻击分类" class="headerlink" title="XSS攻击分类"></a>XSS攻击分类</h3><p>根据攻击的来源，可以将XSS攻击分以下类型：</p><ul><li>存储型攻击</li></ul><p>该攻击常见于论坛博主发贴，网站用户评论，网站用户留言等场景，攻击者将<strong>恶意脚本存储到目标网站</strong>上。</p><p>实现方式：<br>1、攻击者将恶意脚本提交到目标网站数据库中。<br>2、用户打开该网站浏览时，浏览器发送请求恶意脚本从数据库中读取，拼接在页面HTML中。<br>3、浏览器接收到响应后解析执行。<br>4、混在其中的恶意脚本也被执行，恶意脚本窃取用户数据，如：Cookie，发送到攻击者网站。</p><ul><li>反射型攻击</li></ul><p>该攻击常见于网站搜索，跳转等场景，通过URL传递参数，需要用户主动打开恶意的URL才会生效。攻击者将<strong>恶意脚本存储到URL</strong>里。</p><p>实现方式：<br>1、攻击者构造出特殊的URL并添加恶意脚本。<br>2、用户打开带有恶意脚本的URL，服务端将恶意脚本从URL中取出，拼接在HTML中返回给浏览器。<br>3、浏览器接收到响应后解析执行。<br>4、混在其中的恶意脚本也被执行，恶意脚本窃取用户数据，如：Cookie，发送到攻击者网站。</p><ul><li>DOM型攻击</li></ul><p>该攻击常发生于用户的输入来动态的构造一个DOM节点场景，如果没有对用户的输入进行过滤，很有可能造成XSS攻击。<strong>基于DOM的XSS</strong>取出恶意脚本和执行恶意脚本<strong>由浏览器端完成</strong>，服务端不参与。</p><p>实现方式：<br>1、攻击者构造出特殊的URL并添加恶意脚本。<br>2、用户打开带有恶意脚本的URL。<br>3、浏览器接收到响应后解析执行，前端JavaScript取出URL中的恶意脚本并执行。<br>4、恶意脚本窃取用户数据，如：Cookie，发送到攻击者网站。</p><h3 id="XSS防御策略"><a href="#XSS防御策略" class="headerlink" title="XSS防御策略"></a>XSS防御策略</h3><ul><li>客户端对用户有明确的输入类型，例如：数字，URL，手机号，邮箱等内容进行安全符转义，服务端对提交的内容进行安全转义。</li><li>对输入和URL参数进行过滤，对输出进行编码；和白名单结合。</li><li>避免拼接HTML。如果框架允许，使用createElement，setAttribute等之类的方法实现，或者采用比较成熟的框架，如：Vue/React。</li><li>要警惕插入位置为DOM属性，链接等位置。</li><li>尽量不要使用onClick=”fn(‘‘)”等形式内联事件的写法。可以通过addEventListener事件绑定更安全。</li><li>服务端渲染开启模版引擎自带的HTML转义功能。</li><li>增加验证码功能，防止脚本冒充用户提交危险操作。</li><li>限制用户输入长度，增加攻击的难度。</li><li>设置Http-Only Cookie 禁止JavaScript读取敏感Cookie，攻击者完成XSS注入也无法窃取Cookie。</li><li>避免第三方跨域提交内容到服务端。</li></ul><h3 id="CSRF的介绍"><a href="#CSRF的介绍" class="headerlink" title="CSRF的介绍"></a>CSRF的介绍</h3><p>CSRF全称Cross-Site Request Forgery(跨站请求伪造)，攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p><h3 id="CSRF的特点"><a href="#CSRF的特点" class="headerlink" title="CSRF的特点"></a>CSRF的特点</h3><ul><li>攻击一般在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。</li><li>攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作，而不是直接窃取数据。</li><li>整个过程攻击者并不能获取到受害者的登录凭证，仅仅是冒用。</li><li>跨站请求可以用各种方式，如：图片URL，超链接，Form等。部分请求方式可以直接嵌入在第三方论坛中，难以追踪。</li></ul><p><strong>CSRF通常是跨域的</strong>，因为<strong>外域</strong>通常更容易被攻击者<strong>掌握</strong>。反之，在本域下进行，如：可以发链接的评论，攻击反而更加危险。</p><h3 id="CSRF攻击分类"><a href="#CSRF攻击分类" class="headerlink" title="CSRF攻击分类"></a>CSRF攻击分类</h3><ul><li>GET类型的CSRF</li></ul><p>该攻击方式只需要一个HTTP请求，一般是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;http://www.xxx.com?time=100&amp;keyword=get&quot; alt=&quot;&quot; /&gt;</span><br></pre></td></tr></table></figure><p>受害者在访问这个图片页面后，浏览器自动向：<code>http://www.xxx.com?account=danger&amp;time=100&amp;keyword=get</code>发送一次HTTP请求。<code>www.xxx.com</code>会包含受害者登录信息的一次跨域请求。</p><ul><li>POST类型的CSRF。</li></ul><p>该攻击方式通常使用的是一个自动提交的表单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;http://www.xxx.com&quot; method=&quot;POST&quot;&gt;</span><br><span class="line">  &lt;input type=&quot;hidden&quot; name=&quot;time&quot; value=&quot;100&quot; /&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;script&gt; document.forms[0].submit(); &lt;/script&gt;</span><br></pre></td></tr></table></figure><p>用户访问该页面，表单会自动提交，完成了模拟POST操作。一般在网站上传功能上很有可能是发起攻击的来源。</p><ul><li>链接类型的CSRF。</li></ul><p>该攻击方式通常发生在论坛发布图片嵌入恶意链接，或者以广告的形式诱导用户点击，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;http://www.xxx.com/csrf&quot;&gt;充1元送1000&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>这种方式是用户之前登录了信任网站A，并且保存了登录状态。只要用户主动访问这个页面，攻击者就能攻击成功。</p><h3 id="CSRF防御策略"><a href="#CSRF防御策略" class="headerlink" title="CSRF防御策略"></a>CSRF防御策略</h3><ul><li>添加token验证</li></ul><p>本站点的接口请求前在头部添加token用于鉴别身份，第三方站点不能获取头部token。</p><p>该方式弊端：token鉴权对服务器压力较大；页面form提交，超链接不能形成统一的token增加入口，造成部分疏漏。</p><ul><li>服务端通过Referer Header和Origin Header进行同源验证。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;http://www.xxx.com/csrf&quot; referrerpolicy=&quot;no-referrer&quot;&gt;...&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>该方式弊端：<br>1、可以部分修改或隐藏Referer。<br>2、在低版本浏览器下对Referer和Origin不是很稳定。<br>3、在一些浏览器或操作会丢失Origin头部，如：302重定向。<br>4、HTTPS跳转到HTTP，所有浏览器Referer都会丢失。</p><ul><li>禁止第三方网站获取Cookie。</li></ul><p>可以设置Chrome的SameSite属性，而SameSite兼容性不好。</p><ul><li>利用双重Cookie认证。</li></ul><p>每个请求的参数都添加scrfCookie=’随机数’ 防御参数，并在Cookie中混入该防御参数值，服务端请求头部的Cookie中的Cookie参数和请求参数所带的该参数进行对比。</p><p>该方式弊端：<br>如果前后端代码分离，前端和后端接口不同源，如：前端为<code>www.a.com</code>，后端为<code>api.a.com</code>，前端要拿到后端接口下的Cookie，必须将Cookie放在<code>a.com</code>下才能保证子域下都可以获取到，然而这样会增加XSS攻击风险。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇到这里算是结束了，从以上内容可以知晓：防范XSS是需要前端和后端共同参与的，针对DOM型攻击需要前端完成，选择适合的转义库，在不同的上下文调用不同的转义规则；防范CSRF，自动防御策略需要使用同源检测(Referer和Origin验证)，主动防御策略增加Token验证或双重Cookie验证，以及配合Samesite Cookie。为了更好的防御，最佳实践应结合防御措施优缺点和Web应用程序自身情况选择适合方案。文章可能存在一些没有说清楚的地方或者有错的地方，欢迎指正~</p><p>参考资料：</p><ul><li>XSS防御方法总结</li><li><a href="https://www.cnblogs.com/meituantech/p/9718677.html" target="_blank" rel="noopener">前端安全系列（一）：如何防止XSS攻击？</a></li><li><a href="https://blog.csdn.net/MeituanTech/article/details/83023558" target="_blank" rel="noopener">前端安全系列之二：如何防止CSRF攻击？</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;最近线上项目被他人攻击，对网站危害极大。之前对前端安全知识只是大致了解，简单应用。为了更详细的了解与应用前端安全知识，因此查找与前端安全相关
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://blog.yuanbeauty.com/categories/JavaScript/"/>
    
      <category term="JavaScript安全" scheme="http://blog.yuanbeauty.com/categories/JavaScript/JavaScript%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>学习Flex知识</title>
    <link href="http://blog.yuanbeauty.com/archives/48632995.html"/>
    <id>http://blog.yuanbeauty.com/archives/48632995.html</id>
    <published>2019-02-25T16:00:00.000Z</published>
    <updated>2019-02-25T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前都是使用传统的CSS布局方式，但随着CSS3广泛应用在移动端和主流浏览器中，抱着求学的心态学习接收前端新的知识Flex布局，在这里做下笔记进行总结。</p><hr><h3 id="Flex使用"><a href="#Flex使用" class="headerlink" title="Flex使用"></a>Flex使用</h3><p>设置Flex布局，在父框添加 display:flex即可。</p><p>Flex布局有浏览器兼容性，需要根据不同浏览器内核添加不同浏览器前缀，比如Chrome浏览器使用 -webkit- 前缀。</p><p><strong>注意：</strong> 如果用了弹性布局，子元素不需要浮动 float。</p><h3 id="父框设置Flex携带属性"><a href="#父框设置Flex携带属性" class="headerlink" title="父框设置Flex携带属性"></a>父框设置Flex携带属性</h3><p>justify-content: 子元素水平排列方式，值有以下几种：</p><ul><li>center 居中，(常用)</li><li>space-between    两端对齐(常用)</li><li>space-around    子元素拉手分布    (常用)</li><li>flex-start 居左</li><li>flex-end 居右</li></ul><p>align-items: 子元素垂直排列，值有以下几种：</p><ul><li>center 居中(常用)</li><li>flex-end 底部</li><li>flex-start 开始</li></ul><p>align-content:多行的时候，垂直排列</p><ul><li>center 居中<br>…</li></ul><p>flex-direction: 排列方式，该属性值有以下几种：</p><ul><li>row 横向排列</li><li>row-reverse 横向翻过排列</li><li>column 纵向排列</li><li>column-reverse 纵向翻过排列</li></ul><p>flex-wrap: 子元素是否在一行显示，该属性值有以下几种：</p><ul><li>nowrap 不换行</li><li>wrap 换行</li></ul><p>flex-flow 全拼是 <code>&lt;flex-direction&gt;</code> 与 <code>&lt;flex-wrap&gt;</code>的缩写。    </p><h3 id="子框身上属性"><a href="#子框身上属性" class="headerlink" title="子框身上属性:"></a>子框身上属性:</h3><p>父框设置Flex布局，子框携带的属性：</p><ul><li>flex:1，1 指的是一个系数。</li><li>子元素在划分父元素宽度，先刨除固定宽度。</li><li>align-self 其实就是用来覆盖父级 align-items  垂直排列。</li><li>flex-grow: 1;    定义子元素放大比例。</li><li>order: 规定子元素顺序。排序：数值越小，越靠前，默认值0。</li></ul><h3 id="flex：1的含义"><a href="#flex：1的含义" class="headerlink" title="flex：1的含义"></a>flex：1的含义</h3><ul><li>flex是flex-grow，flex-shrink，flex-basis的缩写。</li><li>flex-grow：父控件空间有剩余是否放大；0表示不放大。</li><li>flex-shrink：父控件空间不足是否缩小。</li><li>flex-basis：子控件占主轴的大小，主轴就是flex的主方向，row是横向，column是竖向。</li><li>flex默认属性是0 1 auto，(父控件有剩余控件不放大，父控件空间不足按1缩小，保持本身的空间大小)。</li><li>flex:1;的值是1 1 0%，(父控件有剩余空间按1放大，父控件空间不足按1缩小，自身的空间大小是0%)。</li></ul><p>参考资料：</p><ul><li><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">Flex 布局教程：语法篇</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;之前都是使用传统的CSS布局方式，但随着CSS3广泛应用在移动端和主流浏览器中，抱着求学的心态学习接收前端新的知识Flex布局，在这里做下笔
      
    
    </summary>
    
    
      <category term="CSS" scheme="http://blog.yuanbeauty.com/categories/CSS/"/>
    
      <category term="Flex布局" scheme="http://blog.yuanbeauty.com/categories/CSS/Flex%E5%B8%83%E5%B1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>格式化时间与ElementTree注意点</title>
    <link href="http://blog.yuanbeauty.com/archives/8bd98ba7.html"/>
    <id>http://blog.yuanbeauty.com/archives/8bd98ba7.html</id>
    <published>2018-07-27T16:00:00.000Z</published>
    <updated>2018-07-27T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p>开发Vue项目遇到的问题与技巧。</p><h3 id="格式化时间"><a href="#格式化时间" class="headerlink" title="格式化时间"></a>格式化时间</h3><p>之前处理日期会判断是否大于10，否则在前面加上<code>0</code>进行拼接，有了ES6对字符串进行扩展，提供了便捷；只需要转化成字符串，就能快捷格式化时间；不能写很多判断。</p><p>思路：</p><ul><li><p>把当前时间转化成字符串</p></li><li><p>使用字符串padStart方法，自动添加<code>0</code>进行补齐。</p></li></ul><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">export default&#123;</span><br><span class="line">methods: &#123;</span><br><span class="line">initDate(day) &#123;</span><br><span class="line">let timeDate,Y,M,D,h,m,s;</span><br><span class="line">timeDate = new Date();</span><br><span class="line">timeDate.setDate(timeDate.getDate() + day);</span><br><span class="line">Y = timeDate.getFullYear();</span><br><span class="line">M = (timeDate.getMonth() + 1).toString().padStart(2, &apos;0&apos;);</span><br><span class="line">D = timeDate.getDate().toString().padStart(2, &apos;0&apos;);</span><br><span class="line">h = timeDate.getHours().toString().padStart(2, &apos;0&apos;);</span><br><span class="line">m = timeDate.getMinutes().toString().padStart(2, &apos;0&apos;);</span><br><span class="line">s = timeDate.getSeconds().toString().padStart(2, &apos;0&apos;);</span><br><span class="line">return `$&#123;Y&#125;-$&#123;M&#125;-$&#123;D&#125; $&#123;h&#125;:$&#123;m&#125;:$&#123;s&#125;`;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ElementTree"><a href="#ElementTree" class="headerlink" title="ElementTree"></a>ElementTree</h3><p>如下图：</p><p><img src="/images/1_2.jpg" alt="ElementTree"></p><p>问题：</p><p>前端根据后端API开发数据交互，点击树形节点，会展示当前树形下的子节点。由于树形支持自定义icon，就使用<code>icon-class</code>自定义icon，但是点击同一级icon永远显示第一个子节点数据。</p><p>解决办法：</p><p>使用 <code>pointer-events:none</code> 结合 <code>cursor: default</code>。</p><p>pointer-events:none 表示不能使用鼠标事件点击。</p><p>cursor: default 表示鼠标没有小手状态。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;开发Vue项目遇到的问题与技巧。&lt;/p&gt;
&lt;h3 id=&quot;格式化时间&quot;&gt;&lt;a href=&quot;#格式化时间&quot; class=&quot;headerlink&quot; title=&quot;格式化时间&quot;&gt;&lt;/a&gt;格式化时间&lt;/h3&gt;&lt;p&gt;之前处理日期会
      
    
    </summary>
    
    
      <category term="Vue" scheme="http://blog.yuanbeauty.com/categories/Vue/"/>
    
      <category term="ElementTree" scheme="http://blog.yuanbeauty.com/categories/Vue/ElementTree/"/>
    
    
  </entry>
  
  <entry>
    <title>补充深度克隆</title>
    <link href="http://blog.yuanbeauty.com/archives/1102c4d5.html"/>
    <id>http://blog.yuanbeauty.com/archives/1102c4d5.html</id>
    <published>2018-06-17T16:00:00.000Z</published>
    <updated>2018-06-17T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言：</strong><br>在<a href="http://localhost:4000/blog/2015/08/10.html" target="_blank" rel="noopener">学习JavaScript基础篇</a>提到深度克隆与浅度克隆，最近在云栖社区看到有另一种深度克隆写法，因此记下笔记。</p><p>实现思路：</p><ul><li><p>利用ES6的数组原方法Array.isArray判断数据类型。</p></li><li><p>如果是引用数据类型循环递归判断，否则输出。</p></li></ul><p>代码片段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function deepClone(origin)&#123;</span><br><span class="line">var newObj = (Array.isArray(origin)) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">for(var key in origin)&#123;</span><br><span class="line">newObj[key] = (typeof origin[key] == &apos;object&apos;) </span><br><span class="line">? deepClone2(origin[key])</span><br><span class="line">: origin[key]; </span><br><span class="line">&#125;</span><br><span class="line">return newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;前言：&lt;/strong&gt;&lt;br&gt;在&lt;a href=&quot;http://localhost:4000/blog/2015/08/10.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;学习JavaScript基础篇&lt;/a&gt;提到深度克隆与浅度
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://blog.yuanbeauty.com/categories/JavaScript/"/>
    
      <category term="深度克隆" scheme="http://blog.yuanbeauty.com/categories/JavaScript/%E6%B7%B1%E5%BA%A6%E5%85%8B%E9%9A%86/"/>
    
    
  </entry>
  
  <entry>
    <title>优化网络请求性能节流与防抖</title>
    <link href="http://blog.yuanbeauty.com/archives/6644c399.html"/>
    <id>http://blog.yuanbeauty.com/archives/6644c399.html</id>
    <published>2018-05-17T16:00:00.000Z</published>
    <updated>2018-05-17T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p>界面供用户频繁操作的地方，如果不加以限制，频繁操作增加服务器压力，服务器响应不及时，后端接口出现异常随之带来就是后端处理逻辑抛出异常。</p><p>有以下情景：</p><ul><li>网站点击按钮，用户疯狂点击(click)；</li><li>界面频繁滚动(scroll)；</li><li>频繁调整窗口(resize);</li><li>网站搜索框输入，下面显示有关内容列表(keyup)；</li><li>用户操作拖拽(drag)；</li></ul><p>遇到以上问题，可以使用网络请求性能 — 节流与防抖来解决。</p><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p>理解：预定义一个函数，只有在大于或等于执行周期才能执行，在周期内不执行。</p><p>实现：</p><ul><li>使用时间戳判断是否到达回调函数执行时间，记录上一次时间戳；</li><li>每次触发事件，回调函数判断当前时间戳与上次执行时间戳间隔是否到达指定时间；</li><li>如果是，则执行，并更新上一次执行时间，进行下次循环，如此反复进行。</li></ul><p>相关代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;price&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;button id=&quot;btn&quot;&gt;click me&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">var Div = document.getElementById(&apos;price&apos;), </span><br><span class="line">    Btn = document.getElementById(&apos;btn&apos;);</span><br><span class="line"></span><br><span class="line"> function throttle(handle, wait) &#123;</span><br><span class="line">   var lastTime = 0;</span><br><span class="line">   var arg = arguments;</span><br><span class="line">   return function() &#123;</span><br><span class="line">     var nowTime = new Date().getTime();</span><br><span class="line">     if(nowTime - lastTime &gt; wait) &#123;</span><br><span class="line">       handle.apply(this, arg);</span><br><span class="line">       lastTime = nowTime;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> function pay() &#123;</span><br><span class="line">   Div.innerText = parseInt(Div.innerText) + 1;</span><br><span class="line"> &#125;</span><br><span class="line"> Btn.onclick = throttle(pay, 1000);</span><br></pre></td></tr></table></figure></p><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p>理解：函数频繁触发情况下，只有足够空闲时间，才执行一次。</p><p>实现：</p><ul><li>创建一个定时器，指定时间间隔之后执行回调函数；</li><li>在第二次执行回调函数时，清除前一次的定时器并设置一个新定时器；</li><li>如果前一个定时器执行过了，回调函数就不能执行；</li><li>如果前一个定时器未执行，将替换为一个新的定时器，延迟一定时间再执行。</li></ul><p>相关代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; id=&quot;search&quot; /&gt;</span><br><span class="line">var search = document.getElementById(&apos;search&apos;);</span><br><span class="line">function debounce(handle, wait) &#123;</span><br><span class="line">  var timer = null;</span><br><span class="line">  var arg = arguments;</span><br><span class="line">  return function() &#123;</span><br><span class="line">    clearTimeout(timer);</span><br><span class="line">    timer = setTimeout(function() &#123;</span><br><span class="line">      handle.apply(this, arg)</span><br><span class="line">    &#125;, wait)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function ajax(arg) &#123;</span><br><span class="line">  console.log(arg.target.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">search.onkeyup = debounce(ajax, 1000);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;界面供用户频繁操作的地方，如果不加以限制，频繁操作增加服务器压力，服务器响应不及时，后端接口出现异常随之带来就是后端处理逻辑抛出异常。&lt;/p&gt;
&lt;p&gt;有以下情景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;网站点击按钮，用户疯狂点击(c
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://blog.yuanbeauty.com/categories/JavaScript/"/>
    
      <category term="节流与防抖" scheme="http://blog.yuanbeauty.com/categories/JavaScript/%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/"/>
    
    
  </entry>
  
  <entry>
    <title>学习ES6</title>
    <link href="http://blog.yuanbeauty.com/archives/768f3ad2.html"/>
    <id>http://blog.yuanbeauty.com/archives/768f3ad2.html</id>
    <published>2017-12-19T16:00:00.000Z</published>
    <updated>2017-12-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言：</strong><br>时代不断向前，时刻要跟上步伐，要不断保持学习。最新开始做新项目，基于前端工程化用到很多新知识，比如ES6；因此趁机学习补齐短板。</p><h3 id="let-const定义变量"><a href="#let-const定义变量" class="headerlink" title="let, const定义变量"></a>let, const定义变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">var fn 存在变量声明; 声明的变量会给window增加属性（全局作用域下）</span><br><span class="line">var 只会提前声明, fn 即声明又定义</span><br><span class="line"></span><br><span class="line">console.log(a, fn)</span><br><span class="line">var a;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fn</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">var a = 2;</span><br><span class="line">console.log(window.a) //2</span><br><span class="line"></span><br><span class="line">//没有变量提升</span><br><span class="line">//不可以重复声明</span><br><span class="line">//不会给window增加属性</span><br><span class="line">console.log(a); //<span class="string">'a'</span> has already been declared</span><br><span class="line"><span class="built_in">let</span> a = 1;</span><br><span class="line">console.log(window.a) //undefined</span><br><span class="line"></span><br><span class="line">//没有变量提升</span><br><span class="line">//不可以重复声明</span><br><span class="line">//不会给window增加属性</span><br><span class="line">//定义变量一旦声明必须赋值</span><br><span class="line">//定义的是一个常量（不可以重新赋值）</span><br><span class="line">const a = 1;</span><br><span class="line"></span><br><span class="line">块级作用域</span><br><span class="line">//在fn&#123;&#125; <span class="keyword">for</span>&#123;&#125; <span class="keyword">if</span>&#123;&#125; obj&#123;&#125;情况下, 一个&#123;&#125;就是一个块级作用域;</span><br><span class="line">//在块级作用域下, var 和fn声明的变量依然是全局的</span><br><span class="line">//在块级作用域下, <span class="built_in">let</span>和const声明的变量是私有的</span><br><span class="line">// &#123;&#125; 想表示一个对象, 不可以放在行首</span><br><span class="line">&#123;</span><br><span class="line">var a = 0;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fn</span></span>() &#123;&#125;</span><br><span class="line"><span class="built_in">let</span> b = 1;</span><br><span class="line">&#125;</span><br><span class="line">console.log(a); //0</span><br><span class="line">fn();</span><br><span class="line">console.log(b); // b not undefined</span><br><span class="line">//&#123;name:<span class="string">'sunny'</span>&#125; 看成一个块级作用域</span><br><span class="line">//转变 (&#123;name:<span class="string">'sunny'</span>&#125;) </span><br><span class="line">console.log(<span class="built_in">eval</span>(<span class="string">'(&#123;name:'</span>sunny<span class="string">'&#125;)'</span>));</span><br><span class="line"></span><br><span class="line">//<span class="function"><span class="title">if</span></span>()&#123;&#125; 中的fn只会提前声明不会定义, 当条件成立先给函数赋值, 代码再执行</span><br><span class="line">console.log(a);</span><br><span class="line">console.log(fn);</span><br><span class="line"><span class="keyword">if</span>(1或0) &#123;</span><br><span class="line">console.log(fn);</span><br><span class="line">var a = 1;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fn</span></span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">for</span></span>() &#123;&#125; 点击li获取索引</span><br></pre></td></tr></table></figure><h3 id="结构赋值"><a href="#结构赋值" class="headerlink" title="结构赋值"></a>结构赋值</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [1, 2, 3, 4, 5];</span><br><span class="line">//<span class="built_in">let</span> x = arr[0];</span><br><span class="line">//<span class="built_in">let</span> y = arr[1];</span><br><span class="line">//<span class="built_in">let</span> z = arr[3];</span><br><span class="line"><span class="built_in">let</span>[x, y, z, m] = arr;</span><br><span class="line">console.log(x, y, z);</span><br><span class="line">//设置默认值 只有后面结构的值是undefined时候才会走默认值</span><br><span class="line"><span class="built_in">let</span>[x, y=10] = [1, 2];</span><br><span class="line">console.log(x, y); //1 2</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span>[x, y=10] = [1];</span><br><span class="line">console.log(x, y); //1 10</span><br><span class="line">//省略赋值</span><br><span class="line"><span class="built_in">let</span> [ , , z] = [1, 2, 3];</span><br><span class="line">console.log(z); //3</span><br><span class="line">//不定参数 将后面的项放在一个数组中赋值给y3</span><br><span class="line"><span class="built_in">let</span> [x, y, ...y3] = [1, 2, 3, 4];</span><br><span class="line">console.log(y3);// [3, 4]</span><br><span class="line">//对象的结构赋值 </span><br><span class="line">//如果变量名和属性名一样, 可以直接省略写法</span><br><span class="line"><span class="built_in">let</span> &#123;name&#125; = &#123;name:<span class="string">'sunny'</span>&#125;;</span><br><span class="line">console.log(name)</span><br><span class="line">//对象设置默认值</span><br><span class="line"><span class="built_in">let</span> &#123;name, age:18&#125; = &#123;name:<span class="string">'sunny'</span>, age:undefined&#125;;</span><br><span class="line">console.log(name, age); // sunny 18</span><br><span class="line">//嵌套</span><br><span class="line"><span class="built_in">let</span> &#123;name, age:18, list&#125; = &#123;name:<span class="string">'sunny'</span>, age:undefined, list:[<span class="string">'js'</span>, <span class="string">'vue'</span>]&#125;;</span><br><span class="line">console.log(name. age, x1, x2); //sunny 18 js vue</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> x, y;</span><br><span class="line">[x, y] = [1, 2];</span><br><span class="line">console.log(x, y); //1 2</span><br><span class="line">(&#123;x, y&#125; = &#123;x:1, y:2&#125;);</span><br><span class="line">console.log(x, y); //1 2</span><br><span class="line">//使用数组结构赋值, 如果等号右边不是一个数组, 默认将其转化为类数组</span><br><span class="line"><span class="built_in">let</span>[x, y] = <span class="string">'123'</span>;</span><br><span class="line">console.log(x, y); //1 2</span><br><span class="line">//使用对象结构赋值, 如果等号右边右边不是一个对象, 默认将其转化为对象</span><br><span class="line"><span class="built_in">let</span> &#123;a&#125; = 1;</span><br><span class="line">console.log(a); //undefined</span><br><span class="line">console.log(Object(a)); //&#123;__proto__:&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> &#123;length:a&#125; = <span class="string">'123'</span>;</span><br><span class="line">console.log(Object(<span class="string">'123'</span>));</span><br><span class="line">console.log(a);</span><br><span class="line"></span><br><span class="line">函数结构赋值</span><br><span class="line"><span class="keyword">function</span> fn([x, y, ...z]) &#123;</span><br><span class="line">console.log(x, y, z); //1, 2, [3, 4]</span><br><span class="line">&#125;</span><br><span class="line">fn(1, 2, 3, 4);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> fn(&#123;name=<span class="string">'cherry'</span>, age=18&#125;) &#123;</span><br><span class="line">console.log(name, age); //sunny 18</span><br><span class="line">&#125;</span><br><span class="line">fn(&#123;name:<span class="string">'sunny'</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> fn(&#123;name=<span class="string">'cherry'</span>, age=18&#125;=&#123;&#125;) &#123;</span><br><span class="line">console.log(name, age); </span><br><span class="line">&#125;</span><br><span class="line">fn();//sunny 18</span><br><span class="line">fn(&#123;&#125;);// sunny 18</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> fn(&#123;name, age&#125;=&#123;name:<span class="string">'sunny'</span>, age:18&#125;) &#123;</span><br><span class="line">console.log(name, age); </span><br><span class="line">&#125;</span><br><span class="line">fn(); //sunny 18</span><br><span class="line">fn(&#123;&#125;);//undefined undefined</span><br></pre></td></tr></table></figure><h3 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">console.log(String.prototype);</span><br><span class="line">//include 返回值布尔 <span class="literal">true</span>/<span class="literal">false</span></span><br><span class="line">//片段字符串中有没有指定字符</span><br><span class="line">//includes(指定字符, 开始查找的位置(可选))</span><br><span class="line">//参数2 如果不是数字默认会转化为数字 Number方法转化</span><br><span class="line"><span class="built_in">let</span> str = <span class="string">'abc123'</span>;</span><br><span class="line">console.log(str.includes(<span class="string">'a'</span>)); //<span class="literal">true</span></span><br><span class="line">console.log(str.includes(<span class="string">'a'</span>, 2)); //<span class="literal">false</span></span><br><span class="line">console.log(str.includes(<span class="string">'a'</span>, null)); //<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">//startsWith endsWith</span><br><span class="line">//startsWith 判断字符串是不是以指定字符作为开头</span><br><span class="line">//语法：startsWith(<span class="string">'指定字符'</span>, 开始查找的位置(可选))</span><br><span class="line">console.log(str.startsWith(<span class="string">'a'</span>)); //<span class="literal">true</span></span><br><span class="line">//endsWith 判断字符串是不是以指定字符作为结尾</span><br><span class="line">//语法： endsWith(<span class="string">'指定字符'</span>, n); n：从前n个中查看 </span><br><span class="line">console.log(str.startsWith(<span class="string">'c'</span>, 3)); //<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">//repeat(n) 将字符串重复n次; n 取整 不可以是负数 Infinity</span><br><span class="line">//0到-1, 取整0</span><br><span class="line"><span class="built_in">let</span> str = <span class="string">'123'</span>; </span><br><span class="line">console.log(str.repeat(2)); //123123</span><br><span class="line"></span><br><span class="line">//padStart padEnd; 按照指定字符补全字符串的指定长度 (es7方法)</span><br><span class="line">//参数1：长度lenght, 参数2：指定字符</span><br><span class="line">//语法： padStart/padEnd(length, <span class="string">'指定字符'</span>)</span><br><span class="line"><span class="built_in">let</span> str = <span class="string">'ab'</span>;</span><br><span class="line">console.log(str.padStart(4, <span class="string">'jj'</span>)); //jab</span><br><span class="line">console.log(str.padStart(5, <span class="string">'cdef'</span>)); //cdeab</span><br></pre></td></tr></table></figure><h3 id="模版字符串"><a href="#模版字符串" class="headerlink" title="模版字符串"></a>模版字符串</h3><pre><code>let name = &apos;sunny&apos;;document.body.innerHTML = `&lt;div&gt;${name}&lt;/div&gt;`;</code></pre><h3 id="Array类上的扩展"><a href="#Array类上的扩展" class="headerlink" title="Array类上的扩展"></a>Array类上的扩展</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">console.dir(Array);</span><br><span class="line">//Array 类, 是一个函数; 返回一个数组</span><br><span class="line">//Array(x, y) 将参数变成一个数组返回 [x, y];</span><br><span class="line">//只有一个参数并且参数是个数字, 返回一个有n个空位的数组</span><br><span class="line">console.log(Array(<span class="string">'3'</span>)); //[<span class="string">'3'</span>]</span><br><span class="line">console.log(Array(3)); //[empty x 3]</span><br><span class="line"></span><br><span class="line">//Array.of() 跟Array一样, 唯一不同是： 参数是一个数字的时候返回是一个只有一项的数组</span><br><span class="line">console.log(Array.of(3)); //[3]</span><br><span class="line"></span><br><span class="line">//Array.from() 返回一个数组; 参数是 数组或类数组</span><br><span class="line">console.log(Array.from([123])); //[123]</span><br><span class="line">console.log(Array.from(<span class="string">'123'</span>)); //[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>]</span><br></pre></td></tr></table></figure><p>数组原型上的扩展方法 (所有数组实例方法 参数从索引n到索引m, 包n不包m)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">console.log(Array.prototype);</span><br><span class="line">//copyWithin 从原数组中读取内容, 替换数组的指定位置的内容</span><br><span class="line">//参数(替换的目标起始位置, 查找的起始位置, 查找的结束位置/默认到结尾)</span><br><span class="line">//原数组length不变, 如果有超出部分截取掉</span><br><span class="line"><span class="built_in">let</span> arr = [1, 2, 3, 4, 5, 6, 7, 8];</span><br><span class="line">console.log(arr.copyWithin(4, 2, 4)); //[1, 2, 3, 4, 3, 4, 7, 8]</span><br><span class="line">console.log(arr.copyWithin(3, 2)); //[1, 2, 3, 3, 4, 5, 6, 7]</span><br><span class="line"></span><br><span class="line">//includes 判断数组中有没有某一项, 参数2是开始查找的位置</span><br><span class="line">console.log([1, 2].include(1)); //<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> arr = [1, 2, 3, 4]; </span><br><span class="line">//遍历数组的方法, 参数是一个函数, 自己函数中的this是window; 改变this指向, 可以通过第二个参数改变函数中的this</span><br><span class="line">//reduce, reduceRight不可以改变this, 第二参数给初始值赋值</span><br><span class="line"></span><br><span class="line">//fill 按照指定字符填充数组的指定位置(会改变原数组) </span><br><span class="line">//将数组的每一项都变成指定字符</span><br><span class="line">console.log(arr.fill(<span class="string">'sunny'</span>)); //[<span class="string">'sunny'</span>, <span class="string">'sunny'</span>, <span class="string">'sunny'</span>, <span class="string">'sunny'</span>]</span><br><span class="line">console.log(arr.fill(<span class="string">'sunny'</span>, 2, 3)); //[1, 2,<span class="string">'sunny'</span>, 4]</span><br><span class="line"></span><br><span class="line">//filter 遍历数组, 根据返回值去过滤原数组（原数组不变） es5</span><br><span class="line"><span class="built_in">let</span> arr = [<span class="string">'sunny'</span>, 1, 2, <span class="string">'sunny'</span>];</span><br><span class="line"><span class="built_in">let</span> newArr = arr.filter(<span class="keyword">function</span>(item, index) &#123;</span><br><span class="line">//如果返回<span class="literal">true</span>留下当前项, 返回<span class="literal">false</span>不留下当前项;  结果返回一个新数组 </span><br><span class="line">//<span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">//<span class="built_in">return</span> <span class="literal">false</span></span><br><span class="line"><span class="built_in">return</span> typeof item === <span class="string">'number'</span>;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(newArr); //[1, 2]</span><br><span class="line"></span><br><span class="line">//find 先遍历数组, 一旦参数函数返回<span class="literal">true</span>, 停止查找 返回当前项 (es6)</span><br><span class="line">//只会查找一个</span><br><span class="line"><span class="built_in">let</span> num = arr.find(<span class="keyword">function</span>(item) &#123;</span><br><span class="line"><span class="built_in">return</span> typeof item === <span class="string">'number'</span>;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(num); // 1</span><br><span class="line"></span><br><span class="line">//findIndex 先遍历数组, 一旦参数函数返回<span class="literal">true</span>, 停止查找 返回当前索引</span><br><span class="line">//只会查找一个</span><br><span class="line"><span class="built_in">let</span> index = arr.find(<span class="keyword">function</span>(item) &#123;</span><br><span class="line"><span class="built_in">return</span> typeof item === <span class="string">'string'</span>;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(index); // 0 </span><br><span class="line"></span><br><span class="line">//every 遍历数组, 如果遍历每一项都返回<span class="literal">true</span>, 最后结果为<span class="literal">true</span>; 只要有一个为<span class="literal">false</span>, 结果为<span class="literal">false</span></span><br><span class="line">   <span class="built_in">let</span> num = [1, 2, 3].every(<span class="keyword">function</span>(item) &#123;</span><br><span class="line">   <span class="built_in">return</span> item === <span class="string">'number'</span></span><br><span class="line">&#125;);</span><br><span class="line">console.log(num); //<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">let</span> num = [1, 2, 3, <span class="string">'sunny'</span>].every(<span class="keyword">function</span>(item) &#123;</span><br><span class="line">   <span class="built_in">return</span> item === <span class="string">'number'</span></span><br><span class="line">&#125;);</span><br><span class="line">console.log(num); //<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">//some 遍历数组, 只要有一项都是<span class="literal">true</span>, 结果为<span class="literal">true</span></span><br><span class="line">   <span class="built_in">let</span> num = [1, 2, 3, <span class="string">'sunny'</span>].some(<span class="keyword">function</span>(item) &#123;</span><br><span class="line">   <span class="built_in">return</span> item === <span class="string">'number'</span></span><br><span class="line">&#125;);</span><br><span class="line">console.log(num); //<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">//reduce 迭代</span><br><span class="line"><span class="built_in">let</span> arr = [1, 2, 3];</span><br><span class="line"><span class="built_in">let</span> num = arr.reduce(<span class="keyword">function</span>(prev, item) &#123;</span><br><span class="line">//prev 上一次的返回值</span><br><span class="line">//item 当前项</span><br><span class="line">console.log(prev);</span><br><span class="line">//<span class="built_in">return</span> 1;</span><br><span class="line">// <span class="built_in">return</span> prev + item;</span><br><span class="line">&#125;, n); // n初始的值</span><br><span class="line">console.log(num); // 1 1; 6</span><br><span class="line"></span><br><span class="line">//reduceRight 和reduce顺序相反</span><br><span class="line"></span><br><span class="line">//keys 遍历每一项的索引的接口 使用<span class="keyword">for</span> of遍历</span><br><span class="line">console.log([1, 2].keys());</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">let</span> key of arr.keys()) &#123;</span><br><span class="line">console.log(key); //打印索引</span><br><span class="line">&#125;</span><br><span class="line">//<span class="keyword">for</span> of 遍历数组每一项的值; <span class="keyword">for</span> <span class="keyword">in</span> 遍历数组每一项的索引</span><br><span class="line"></span><br><span class="line">//entries 遍历接口 可以遍历到索引和每一项 每一次遍历得到一个数组[索引, 当前项]</span><br><span class="line">//一般可以通过数组的结构赋值获取到遍历的结果</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">let</span> [index, item] of arr.entries()) &#123;</span><br><span class="line">console.log(index, item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>数组的空位 –&gt; 当前数组的某个索引位置 没有任何值, undefined不是空位<br>    //判断一个数组中某一个位置是不是空位 使用in方法判断<br>    //in 判断数组索引位置上有没有值<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [, , , ,];</span><br><span class="line">console.log(arr.length); //4 --&gt; 查看有几个逗号</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> arr = [, undefined, , ,];</span><br><span class="line">console.log(1 <span class="keyword">in</span> arr); //<span class="literal">true</span></span><br><span class="line">console.log(0 <span class="keyword">in</span> arr); //<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">//es5中数组方法对空位处理不一致, 一般直接跳过空位</span><br><span class="line">//es6中将空位处理为undefined</span><br><span class="line"><span class="built_in">let</span> arr = [1, , , 3];</span><br><span class="line">arr.fillter(<span class="keyword">function</span>(item) &#123;</span><br><span class="line">console.log(item);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">arr.find(<span class="keyword">function</span>(item) &#123;</span><br><span class="line">console.log(item);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">let</span> item of arr) &#123;</span><br><span class="line">console.log(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">//参数默认值</span><br><span class="line"><span class="keyword">function</span> fn(x=<span class="string">'sunny'</span>, y=<span class="string">'cherry'</span>) &#123;</span><br><span class="line">console.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line">fn(0); //0, cherry</span><br><span class="line"></span><br><span class="line">//参数使用结构赋值</span><br><span class="line"><span class="keyword">function</span> fn(&#123;name=<span class="string">'sunny'</span>, age=18&#125;) &#123;</span><br><span class="line">//&#123;name=<span class="string">'sunny'</span>, age=18&#125; = undefined</span><br><span class="line">console.log(name, age)</span><br><span class="line">&#125;</span><br><span class="line">fn(); //undefined undefined </span><br><span class="line"></span><br><span class="line">//length 如果形参有默认值length就会失真, 如果没有默认值就是形参的个数</span><br><span class="line"><span class="keyword">function</span> fn(x, y=10) &#123;&#125;</span><br><span class="line">fn(1, 2);</span><br><span class="line">//fn(, 2); 会报错; 参数默认值一般放在最后面</span><br><span class="line">console.log(fn.length); //1</span><br><span class="line"></span><br><span class="line">//arguments 是一个类数组</span><br><span class="line"><span class="keyword">function</span> fn(...arg) &#123;</span><br><span class="line">console.log(arguments);</span><br><span class="line">console.log(arg); //数组 [1, 2]</span><br><span class="line">&#125;</span><br><span class="line">fn(1, 2);</span><br><span class="line"></span><br><span class="line">有名函数的name</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fn</span></span>() &#123;&#125;</span><br><span class="line">console.log(fn.name) // <span class="string">'fn'</span></span><br><span class="line">console.log((<span class="function"><span class="title">function</span></span>() &#123;&#125;())); // <span class="string">''</span></span><br><span class="line">//特殊情况</span><br><span class="line">//1. 通过<span class="built_in">bind</span>方法得到一个新函数, name是bound + 原函数名</span><br><span class="line"><span class="built_in">let</span> fn1 = fn.bind(null);</span><br><span class="line">console.log(fn1.name); //bound fn</span><br><span class="line"></span><br><span class="line">//2. 通过构造函数方式创建一个函数</span><br><span class="line">//new Functon(<span class="string">'形参'</span>, <span class="string">'函数体'</span>)</span><br><span class="line">//new Function(<span class="string">'函数体'</span>);</span><br><span class="line">// Function fn(形参) &#123; 函数体&#125;</span><br><span class="line"><span class="built_in">let</span> fn2 = new Function(<span class="string">'x, y'</span>, <span class="string">'console.log(x, y)'</span>, <span class="built_in">return</span> x + y);</span><br><span class="line">console.log(10, 100); // 10, 100; 110</span><br><span class="line">console.log(fn2.name);// 匿名</span><br><span class="line"></span><br><span class="line">//JSON字符串变成JSON对象 使用new Function()</span><br><span class="line">var str = <span class="string">'[&#123;name:"sunny"&#125;, &#123;age:18&#125;]'</span>;</span><br><span class="line"><span class="built_in">let</span> arr = (new Function(<span class="string">"return "</span>+str))();</span><br><span class="line">console.log(arr); //arr --&gt; [&#123;name:<span class="string">"sunny"</span>&#125;, &#123;age:18&#125;]</span><br></pre></td></tr></table></figure><h3 id="参数作用域问题"><a href="#参数作用域问题" class="headerlink" title="参数作用域问题"></a>参数作用域问题</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//函数执行时候先给形参赋值, 形参也是私有变量,</span><br><span class="line">//如果给形参的默认值是一个变量, 先看是不是自己的私有变量, 不是自己的, 查看在全局中是否有这个变量, 没有就报错</span><br><span class="line"><span class="built_in">let</span> m = 10, n =100;</span><br><span class="line"><span class="keyword">function</span> fn(x = m, y = n) &#123;</span><br><span class="line">//私有作用域：私有变量 x, y, m, n</span><br><span class="line">console.log(x, y);</span><br><span class="line"><span class="built_in">let</span> m = <span class="string">'sunny'</span>;</span><br><span class="line">//var m = <span class="string">'cherry'</span>;</span><br><span class="line"><span class="built_in">let</span> n = 18</span><br><span class="line">&#125;</span><br><span class="line">fn(); // 10 100</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> x = 10;</span><br><span class="line"><span class="keyword">function</span> fn(x, y = x) &#123;</span><br><span class="line">console.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line">fn(1); // 1 1</span><br></pre></td></tr></table></figure><h3 id="扩展运算符-…"><a href="#扩展运算符-…" class="headerlink" title="扩展运算符 …"></a>扩展运算符 …</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//将非数组变成数组(类数组 length)</span><br><span class="line"><span class="built_in">let</span> str = <span class="string">'123'</span>;</span><br><span class="line">console.log([...str]);//[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>]</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fn</span></span>() &#123;</span><br><span class="line">console.log([...arguments]);</span><br><span class="line">&#125;</span><br><span class="line">fn(1, 2); // [1, 2]</span><br><span class="line">//将数组变成非数组</span><br><span class="line">var arr = [1, 2];</span><br><span class="line">console.log(...arr); 1 2</span><br><span class="line">//求数组最大值</span><br><span class="line"><span class="built_in">let</span> arr = [121, 123, 134];</span><br><span class="line">console.log(Math.max.apply(null, arr));</span><br><span class="line">console.log(<span class="built_in">eval</span>(<span class="string">"Math max("</span>+arr+<span class="string">")"</span>));</span><br><span class="line">console.log(Math.max(...arr));</span><br></pre></td></tr></table></figure><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//箭头函数是匿名函数</span><br><span class="line">//函数体只有一行代码<span class="built_in">return</span> 可以省略</span><br><span class="line">//形参只有一个时候可以省略括号</span><br><span class="line">//语法：<span class="built_in">let</span> fn = (形参)=&gt;&#123; 函数体 &#125;</span><br><span class="line">//注意：</span><br><span class="line">//箭头函数没有this指向, 里面的this是上一级作用域下的this</span><br><span class="line">//箭头函数没有arguments</span><br><span class="line"><span class="built_in">let</span> fn = (...arg)=&gt;&#123;</span><br><span class="line">console.log(arg);</span><br><span class="line">&#125;</span><br><span class="line">fn(1, 2);</span><br><span class="line">//箭头函数不可以用作构造函数 因为不可以使用new执行</span><br><span class="line"><span class="built_in">let</span> F = ()=&gt;&#123;&#125;</span><br><span class="line">console.log(new F);//F not constructor</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> fn = x=&gt;x+1;  == <span class="built_in">let</span> fn = x=&gt;&#123;<span class="built_in">return</span> x+1&#125;</span><br><span class="line">//通常函数当做参数时使用箭头函数</span><br></pre></td></tr></table></figure><h3 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> name = <span class="string">'sunny'</span>, age = 18;</span><br><span class="line"><span class="built_in">let</span> person = &#123;name, age&#125; == person&#123;name:name, age:age&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> str = <span class="string">'cherry'</span>;</span><br><span class="line"><span class="built_in">let</span> obj = &#123;</span><br><span class="line"><span class="function"><span class="title">fn</span></span>() &#123;&#125;,</span><br><span class="line">//fn: <span class="function"><span class="title">function</span></span>() &#123;&#125;</span><br><span class="line">//属性名是字符串 属性名使用[] 里面放变量</span><br><span class="line">[str]:name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Object.is(参数1, 参数2) 判断两个值是否相等</span><br><span class="line">// -0 === 0 <span class="literal">true</span>   NaN === NaN <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">console.dir(Object);</span><br><span class="line"></span><br><span class="line">//Object.assign(参数1, 参数2) 合并对象  将参数2合并到参数1上 返回一个对象</span><br><span class="line"><span class="built_in">let</span> obj1 = &#123;name:<span class="string">'sunny'</span>&#125;;</span><br><span class="line"><span class="built_in">let</span> obj2 = &#123;age:18&#125;;</span><br><span class="line"><span class="built_in">let</span> person = Object.assign(obj1, obj2); //&#123;name:<span class="string">'sunny'</span>, age:18&#125;</span><br><span class="line"></span><br><span class="line">es7中提供了对象的扩展运算符...</span><br><span class="line"><span class="built_in">let</span> person = &#123;...obj1, ...obj2&#125;; //&#123;name:<span class="string">'sunny'</span>, age:18&#125;</span><br><span class="line"></span><br><span class="line">//Object.getOwnPropertyDescriptor 获取一个对象中某个描述</span><br><span class="line">console.log(Object.getOwnPropertyDescriptor(<span class="string">'123'</span>, <span class="string">'length'</span>));</span><br><span class="line"></span><br><span class="line">//字符串的length不可以修改, 字符串中的方法是不可以改变原字符串</span><br><span class="line"><span class="built_in">let</span> str = <span class="string">'123'</span>;</span><br><span class="line">str.length = 0;</span><br><span class="line">console.log(str); //123</span><br><span class="line">/*</span><br><span class="line">* configurable:<span class="literal">false</span> 是否可配置 可以删除这个属性</span><br><span class="line">* enumerable:<span class="literal">false</span> 是否枚举 (用<span class="keyword">for</span> <span class="keyword">in</span>遍历不出来)</span><br><span class="line">* value: 3</span><br><span class="line">* writeable: <span class="literal">false</span> 是否可以修改</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> person = &#123;name:<span class="string">'sunny'</span>, age:18&#125;;</span><br><span class="line"></span><br><span class="line">//Object.keys()  返回值是数组 [所有可枚举的属性]</span><br><span class="line">console.log(Object.keys(person)); //[<span class="string">'name'</span>, <span class="string">'age'</span>]</span><br><span class="line"></span><br><span class="line">//Object.values() 返回值是数组 [所有可枚举的属性的键值]</span><br><span class="line">console.log(Object.values(person)); // sunny 18</span><br><span class="line"></span><br><span class="line">//Object.entries() 返回值是数组 [每一项也是一个数组[键, 值]]</span><br><span class="line">console.log(Object.entries(person)); //[[<span class="string">'name'</span>, <span class="string">'sunny'</span>], [<span class="string">'age'</span>, <span class="string">'18'</span>]]</span><br></pre></td></tr></table></figure><h3 id="对象的set和get"><a href="#对象的set和get" class="headerlink" title="对象的set和get"></a>对象的set和get</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> obj = &#123;</span><br><span class="line">_name: <span class="string">'A'</span>,</span><br><span class="line">get <span class="function"><span class="title">name</span></span>()&#123;</span><br><span class="line">//通过obj获取name属性就会触发这个函数</span><br><span class="line">//可以通过teturn获取返回值</span><br><span class="line">//console.log(1);</span><br><span class="line"><span class="built_in">return</span> this._name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">set</span> name(val) &#123;</span><br><span class="line">//val 设置的值--&gt; 通过obj给name属性设置值就会触发这个函数</span><br><span class="line">//console.log(2); this == obj</span><br><span class="line">this._name = val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(obj.name); // sunny</span><br><span class="line">obj.name = <span class="string">'cherry'</span>;</span><br></pre></td></tr></table></figure><h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">//Symbol 是一个新的基本数据类型  而且是一个值类型</span><br><span class="line">//使用Symbol函数执行 得到一个Symbol数据类型</span><br><span class="line">//Symbol跟字符串类型差不多 但是使用Symbol函数得到一个数据 每一个是完全不同的</span><br><span class="line"><span class="built_in">let</span> sym = Symbol(); </span><br><span class="line"><span class="built_in">let</span> sym2 = Symbol();</span><br><span class="line">typeof sym; //<span class="string">'symbol'</span></span><br><span class="line">sym == sym2; // <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">//Symbol可以接受一个参数(); 参数是对Symbol数据类型的描述</span><br><span class="line">//即使描述一样, 但是值也是不一样的 </span><br><span class="line"><span class="built_in">let</span> sym = Symbol(<span class="string">'fn'</span>);</span><br><span class="line"><span class="built_in">let</span> sym2 = Symbol(<span class="string">'fn'</span>);</span><br><span class="line">sym == sym2; // <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">//一般当做对象的属性； 任意一个Symbol得到的值都是不同的</span><br><span class="line"><span class="built_in">let</span> obj = &#123;</span><br><span class="line">sym: <span class="string">'sunny'</span>,</span><br><span class="line">[sym]: <span class="string">'sunny'</span></span><br><span class="line">&#125;</span><br><span class="line">obj.[sym2] = <span class="string">'sunny'</span>;</span><br><span class="line">console.log(obj); //得到三个不同的值</span><br><span class="line"></span><br><span class="line">//Symbol值不可以跟其他值计算</span><br><span class="line">//Symbol 不可以转化为数字</span><br><span class="line">//Symbol 不可以字符串拼接</span><br><span class="line">console.log(Symbol(<span class="string">'1'</span>) + 1); //报错</span><br><span class="line">Number(Symbol(1)); //报错</span><br><span class="line">Symbol(1) +<span class="string">'1'</span>;</span><br><span class="line"></span><br><span class="line">//可以转化为布尔值</span><br><span class="line">   !Symbol(<span class="string">'1'</span>); //<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">   //可以toString变成显示字符串</span><br><span class="line">   console.log(Symbol(<span class="string">'ZF'</span>).toString()); // <span class="string">"Symbol('ZF')"</span></span><br><span class="line"></span><br><span class="line">   //Symbol.for() 如果之前有相同参数的Symbol的值, 找到这个值返回</span><br><span class="line">   //如果没有找到, 就创建一个新的Symbol值</span><br><span class="line">   <span class="built_in">let</span> foo = Symbol(<span class="string">'sunny'</span>);</span><br><span class="line">   <span class="built_in">let</span> foo2 = Symbol.for(<span class="string">'Sunny'</span>);</span><br><span class="line">   <span class="built_in">let</span> foo3 = Symbol.for(<span class="string">'Sunny'</span>);</span><br><span class="line">   foo == foo2; //<span class="literal">false</span></span><br><span class="line">   foo2 == foo3; // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  // Symbol.keyFor(symbol值) 找到使用Symbol.keyFor()创建的值的描述</span><br><span class="line">  //如果使用的是Symbol创建的是获取不到的 </span><br><span class="line">  Symbol.keyFor(foo2); //sunny</span><br><span class="line">  Symbol.keyFor(foo); //undefined</span><br></pre></td></tr></table></figure><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">//类似数组 只有值val,  没有键key</span><br><span class="line">//通过构造函数方式, 创建一个<span class="built_in">set</span>实例</span><br><span class="line"> new Set(); //&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">//参数是一个数组 或者是类数组 只要是有enterable接口</span><br><span class="line">//有interable接口： 数组, arguments 元素集合 map  Set 字符串</span><br><span class="line">//特点： 会默认去重</span><br><span class="line">new Set([1, 2, 2]); // &#123;1, 2&#125;</span><br><span class="line"></span><br><span class="line">//size: <span class="built_in">set</span>实例的大小个数</span><br><span class="line">// add 增加 如果之前没有则添加上， 如果存在，不加; 返回值是增加后的<span class="built_in">set</span>实例(可以实现链式写法)</span><br><span class="line">//参数一次添加一个</span><br><span class="line"><span class="built_in">let</span>  <span class="built_in">set</span> = new Set([1, 2, null, <span class="literal">true</span>]);</span><br><span class="line">set.add(1).add(10).add(20, 300); // </span><br><span class="line"></span><br><span class="line">//delete(删除的值) 删除 返回值是<span class="literal">true</span>/<span class="literal">false</span> 如果里面有这一项就删除成功/<span class="literal">true</span>, 否则删除失败/<span class="literal">false</span></span><br><span class="line">set.delete(1);// <span class="literal">true</span></span><br><span class="line">set.delete(1000); //<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">//has 判断有没有这一项 返回值是<span class="literal">true</span>/<span class="literal">false</span></span><br><span class="line">set.has(NaN); //<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">//clear 清空; 没有返回值 undefined</span><br><span class="line">set.clear(); //&#123; &#125;</span><br><span class="line"></span><br><span class="line">// forEach keys values entries 遍历方法</span><br><span class="line">set.forEach((item, index, input)=&gt;&#123;</span><br><span class="line">//item, index 当前项</span><br><span class="line">//input 当前<span class="built_in">set</span>实例</span><br><span class="line">console.log(item, index); </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">let</span> key of set.keys()) &#123;</span><br><span class="line">//key 是val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">let</span> value of set.values()) &#123;</span><br><span class="line">//value 是val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">let</span> key of set.entries()) &#123;</span><br><span class="line">//key 是val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="set使用场景"><a href="#set使用场景" class="headerlink" title="set使用场景"></a>set使用场景</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//数组去重</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> arr1 = [1, 3, 5, 8, 9];</span><br><span class="line"><span class="built_in">let</span> arr2 = [2, 4, 6, 8, 0];</span><br><span class="line"></span><br><span class="line">//并集</span><br><span class="line"><span class="keyword">function</span> add(arg, arg2) &#123;</span><br><span class="line"><span class="built_in">return</span> [...new Set([...arg, ...arg2])]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//交集</span><br><span class="line"><span class="keyword">function</span> same(arg, arg2)&#123;</span><br><span class="line"><span class="built_in">return</span> arr.filter(item=&gt;arg2.includes(item));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//差集   并集 - 交集</span><br><span class="line"><span class="keyword">function</span> diff(arg, arg2)  &#123;</span><br><span class="line"><span class="built_in">return</span> add(arg, arg2).filter(item=&gt;!same(arg, aeg2).includes(item));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">//构造函数方式创建一个Map实例</span><br><span class="line">//参数是一个数组, 数组的每一项也是一个数组, 有两项key, value</span><br><span class="line">//属性名不可以重复</span><br><span class="line"><span class="built_in">let</span> map = new Map([[key, val], [] ])</span><br><span class="line"><span class="built_in">let</span> map = new Map([ [], [] ])</span><br><span class="line"></span><br><span class="line">//一个对象属性名必须是一个字符串, 如果写的不是字符串也默认转化为字符串</span><br><span class="line">//Map实例的 可以是任意数字类型</span><br><span class="line">//size: 键值对的个数</span><br><span class="line"><span class="built_in">let</span> map = new Map([[<span class="string">'name'</span>, <span class="string">'snuuy'</span>], [1, <span class="string">'money'</span>], [[1, 2], [1, 2]]]);</span><br><span class="line"></span><br><span class="line">//get(key) 获取value</span><br><span class="line">map.get(<span class="string">'name'</span>); //snuuy</span><br><span class="line"></span><br><span class="line">//<span class="built_in">set</span>(ke, vale); 之前有key, 会修改之前的value; 没有返回新的实例(可以链式写法)</span><br><span class="line">map.set(1, 2);</span><br><span class="line"></span><br><span class="line">//has(key); 判断key有没有对应的value; 返回<span class="literal">true</span>/<span class="literal">false</span></span><br><span class="line">map.has(1);</span><br><span class="line"></span><br><span class="line">//delete(key); 删除实例中的属性; 返回值<span class="literal">true</span>/<span class="literal">false</span></span><br><span class="line">map.delete(1);</span><br><span class="line"></span><br><span class="line">//clear 清空 没有返回值 </span><br><span class="line">map.clear();</span><br><span class="line"></span><br><span class="line">//forEach keys values entries 遍历方法</span><br><span class="line">map.forEach((val, key, input)=&gt;&#123;</span><br><span class="line">console.log(val, key, input);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(var key <span class="keyword">in</span> map.keys()) &#123;</span><br><span class="line">console.log(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(var value <span class="keyword">in</span> map.values()) &#123;</span><br><span class="line">console.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(var [key, val] <span class="keyword">in</span> map.entries()) &#123;</span><br><span class="line">console.log(key, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//???数组变成Map实例</span><br><span class="line">var arr = [...];</span><br><span class="line"><span class="built_in">let</span> map = new Map();</span><br><span class="line"><span class="keyword">for</span>(var [key, val] of arr) &#123;</span><br><span class="line">map.set(key, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p>对象默认操作拦截</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">//new Proxy(&#123;参数1:目标对象&#125;, &#123;参数2:拦截的方法&#125;); </span><br><span class="line"><span class="built_in">let</span> obj = &#123;name:<span class="string">'sunny'</span>&#125;;</span><br><span class="line"></span><br><span class="line">//让proxy代理了 obj; 需要通过proxy 操作代理的obj</span><br><span class="line"><span class="built_in">let</span> proxy = new Proxy(obj, &#123;</span><br><span class="line">//get 只要是获取,  例如：proxy.name 就会触发get</span><br><span class="line">get(target, key, proxy) &#123; // target:目标对象 key：属性名 proxty：当前实例</span><br><span class="line">console.log(arguments);</span><br><span class="line">//<span class="built_in">return</span> <span class="string">'cherry'</span></span><br><span class="line">//<span class="built_in">return</span> 什么, 就获取什么, 或者就是undefined</span><br><span class="line"><span class="built_in">return</span> target[key];</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(proxy.name);//sunny</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> proxy = new Proxy(obj, &#123;</span><br><span class="line">get(target, propKey, receiver) &#123;</span><br><span class="line"><span class="built_in">return</span> target[propKey]</span><br><span class="line">&#125;,</span><br><span class="line"><span class="built_in">set</span>(target, propKey, value, receiver) &#123;</span><br><span class="line">target[propKey] = value;</span><br><span class="line"><span class="built_in">return</span> <span class="literal">true</span></span><br><span class="line">&#125;,</span><br><span class="line">has(target, propKey) &#123;</span><br><span class="line"><span class="keyword">if</span>(propKey.startsWith(<span class="string">'_'</span>)) &#123;</span><br><span class="line"><span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> propKey <span class="keyword">in</span> target;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="title">apply</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;) </span><br><span class="line">proxy.name = <span class="string">'cherry'</span>;</span><br><span class="line">consoel.log(obj);</span><br><span class="line"></span><br><span class="line">console.log(<span class="string">'name'</span> <span class="keyword">in</span> proxy);//<span class="literal">true</span></span><br><span class="line">console.log(<span class="string">'__proto__'</span> <span class="keyword">in</span> proxy);//<span class="literal">false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fn</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> &#123;name:<span class="string">'sunny'</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> proxy = new Proxy(fn,&#123;</span><br><span class="line">apply(target, object, args) &#123;</span><br><span class="line">//函数直接执行 call apply</span><br><span class="line">//args 函数执行的参数</span><br><span class="line">//object 给函数修改this</span><br><span class="line"><span class="keyword">if</span>(object)&#123;</span><br><span class="line">object.fn=target;</span><br><span class="line">object.fn(...args);</span><br><span class="line">delete object.fn;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">target(...args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy();</span><br></pre></td></tr></table></figure><h3 id="class"><a href="#class" class="headerlink" title="class"></a>class</h3><p>class中的constructor<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Fn&#123;</span><br><span class="line">constructor(x) &#123;</span><br><span class="line">//this:当前实例</span><br><span class="line">this.x = x; //增加私有属性</span><br><span class="line">//<span class="built_in">return</span> 的是基本数据类型对实例没有影响, </span><br><span class="line">//如果是引用数据类型 会改变实例</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> fn = new Fn(10); --&gt; &#123; x:10 &#125;</span><br><span class="line">// Fn();  类必须使用new执行, 不可以作为普通函数执行</span><br><span class="line">typeof Fn; // <span class="string">'function'</span></span><br><span class="line"></span><br><span class="line">//class的name问题</span><br><span class="line">class <span class="function"><span class="title">Fn</span></span>()&#123;</span><br><span class="line"><span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">console.log(Fn.name); //Fn</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">getFn</span></span>() &#123;</span><br><span class="line">console.log(Fn.name); //fn</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line"><span class="built_in">let</span> Fn1 = class <span class="function"><span class="title">Fn</span></span>()&#123;</span><br><span class="line">//Fn 只能在类里面使用</span><br><span class="line"><span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">console.log(Fn.name); //Fn  --&gt;就近原则</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line"><span class="built_in">let</span> fn = new Fn();</span><br></pre></td></tr></table></figure></p><p>class中的执行变量<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">constructor(name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> person = new Person(<span class="string">'sunny'</span>);</span><br><span class="line"></span><br><span class="line">//采用class表达式让类执行</span><br><span class="line">// es6中class 和 <span class="built_in">let</span> const 一样没有变量提升</span><br><span class="line"><span class="built_in">let</span> person = new Class&#123;</span><br><span class="line">constructor(name) &#123;</span><br><span class="line">console.log(name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;(<span class="string">'sunny'</span>);</span><br></pre></td></tr></table></figure></p><p>class静态方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">//类就相当于原型, </span><br><span class="line">//写在原型上的方法都被实例继承</span><br><span class="line">//static关键字不会被实例继承 可以被子类继承</span><br><span class="line">class <span class="function"><span class="title">Person</span></span>() &#123;</span><br><span class="line"><span class="function"><span class="title">constructor</span></span>() &#123;&#125;</span><br><span class="line"><span class="function"><span class="title">getName</span></span>() &#123;</span><br><span class="line">console.log(<span class="string">'sunny'</span>);</span><br><span class="line">&#125;</span><br><span class="line">static <span class="function"><span class="title">getAge</span></span>() &#123; //静态方法</span><br><span class="line">console.log(<span class="string">'cherry'</span>); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Son extends Person&#123;</span><br><span class="line"><span class="function"><span class="title">getPerson</span></span>() &#123;</span><br><span class="line">super.getAge()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> person = new Person;</span><br><span class="line">person.getName(); // sunny</span><br><span class="line">person.getAge();</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> son = new Son;</span><br><span class="line">son.getPerson();</span><br><span class="line"></span><br><span class="line">//子类继承父类 子类中没有this; super执行完之后才会有this</span><br><span class="line">class A&#123;</span><br><span class="line">constructor(x) &#123;</span><br><span class="line">//super 父类的constructor</span><br><span class="line">this.x = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">getX</span></span>() &#123;</span><br><span class="line">console.log(this.x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">getY</span></span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A&#123;</span><br><span class="line">constructor(x) &#123;</span><br><span class="line">//super 执行不能写this</span><br><span class="line">//super就是父类的constructor</span><br><span class="line">super(x); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">getA</span></span>() &#123;</span><br><span class="line">//super 指向父类的原型</span><br><span class="line">super.<span class="function"><span class="title">getX</span></span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">//static 父类的静态方法也可以继承</span><br><span class="line">static <span class="function"><span class="title">getY</span></span>() &#123;</span><br><span class="line">//super 指向父类本身</span><br><span class="line">super.getY();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> a = new A(10);</span><br><span class="line"><span class="built_in">let</span> b = new B(100);</span><br></pre></td></tr></table></figure></p><h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">//执行顺序：先执行new Promise中的函数 --&gt; 队列中同步代码 --&gt; <span class="keyword">then</span>中的回调函数</span><br><span class="line"><span class="built_in">let</span> pro = new Promise((resolve, reject)=&gt;&#123;</span><br><span class="line">//resolve </span><br><span class="line">//reject</span><br><span class="line">//resolve 和 reject 只能执行一个</span><br><span class="line">console.log(<span class="string">'promise'</span>)</span><br><span class="line">resolve(<span class="string">'success'</span>);</span><br><span class="line">reject(<span class="string">'error'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">//<span class="keyword">then</span>函数异步执行</span><br><span class="line">pro.then((res)=&gt;&#123;</span><br><span class="line">//resolve 成功的回调</span><br><span class="line">&#125;,(e)=&gt;&#123;</span><br><span class="line">//失败的回调</span><br><span class="line">console.log(e);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//catch捕获错误异常 如果new promise中有错误被捕获</span><br><span class="line">//如果<span class="keyword">then</span>中回调有错误, 也会被捕获; 一般最后添加catch 不会一直向下<span class="keyword">then</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.dir(promise);</span><br><span class="line"></span><br><span class="line">//all </span><br><span class="line">//Promise.all([每一项都是Promise, 如果不是默认转化为Promise])</span><br><span class="line">// 一旦发现有一项是错误 就会走失败;</span><br><span class="line">//每一项都是成功 才会走成功回调; 默认将每一项的参数放在一个数组中, 传给回调函数</span><br><span class="line"><span class="built_in">let</span> pro = new Promise((resolve, reject)=&gt;&#123;</span><br><span class="line">resolve(<span class="string">'ok'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">let</span> pro1 = new Promise((resolve, reject)=&gt;&#123;</span><br><span class="line">reject(<span class="string">'error'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> pro2 = new Promise((resolve, reject)=&gt;&#123;</span><br><span class="line">resolve(<span class="string">'ok'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> proAll = Promise.all([pro, pro1, pro2]);</span><br><span class="line">console.log(proAll);//----</span><br><span class="line">proAll.then((res)=&gt;&#123;</span><br><span class="line">console.log(res); //[<span class="string">'ok'</span>, <span class="string">'ok'</span>]</span><br><span class="line">&#125;, catch(e)=&gt;&#123;</span><br><span class="line">console.log(e)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//race </span><br><span class="line">//只要有一个状态改变, 此时当前实例的状态就改变</span><br><span class="line">Promise.race([pro, pro1, pro2]).<span class="keyword">then</span>((res)=&gt;&#123;</span><br><span class="line">console.log(res);</span><br><span class="line">&#125;, catch(e)=&gt;&#123;</span><br><span class="line">console.log(e);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//实现promiseAll</span><br><span class="line"><span class="keyword">function</span> PromiseAll(promises) &#123;</span><br><span class="line"><span class="built_in">return</span> new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line"><span class="built_in">let</span> index = 0;</span><br><span class="line"><span class="built_in">let</span> res = Array(promises.length);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">let</span> i = 0; i&lt;promises.length;i++) &#123;</span><br><span class="line">promises[i].<span class="keyword">then</span>(val =&gt; &#123;</span><br><span class="line">index ++;</span><br><span class="line">res[i] = val;</span><br><span class="line"><span class="keyword">if</span>(index == promises.length) &#123;</span><br><span class="line">resolve(res);</span><br><span class="line">&#125;</span><br><span class="line">&#125;, error =&gt; &#123;</span><br><span class="line">reject(error);</span><br><span class="line"><span class="built_in">return</span>;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> p1 = new Promise(resolve =&gt; resolve(<span class="string">'p1'</span>));</span><br><span class="line"><span class="built_in">let</span> p2 = new Promise(resolve =&gt; resolve(<span class="string">'p2'</span>));</span><br><span class="line">//<span class="built_in">let</span> p3 = Promise.reject(<span class="string">'p3'</span>);</span><br></pre></td></tr></table></figure><h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//async 默认返回一个Promise对象</span><br><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">fn</span></span>() &#123;</span><br><span class="line">//<span class="built_in">return</span>出的内容就是成功回调函数</span><br><span class="line">//有错误就会被catch捕获到</span><br><span class="line"><span class="built_in">return</span> <span class="string">'sunny'</span>;</span><br><span class="line">&#125;</span><br><span class="line">fn().<span class="keyword">then</span>((res)=&gt;&#123;</span><br><span class="line">console.log(res); //sunny</span><br><span class="line">&#125;, catch(e) &#123;</span><br><span class="line">console.log(e);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> p = new Promise((resolve, reject)=&gt;&#123;</span><br><span class="line">resolve(<span class="string">'sunny'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">//await 后面是一个promise实例, 如果不是也会转化为promise</span><br><span class="line">//直接让promise实例的回调执行, 返回执行时的参数</span><br><span class="line">//await 不用通过<span class="keyword">then</span>就可以拿到resolve或reject参数</span><br><span class="line">console.log(await p); // sunny</span><br><span class="line">//先将await 后面的异步执行完成后, 再执行后面的代码</span><br><span class="line"><span class="built_in">let</span> a = await p;</span><br><span class="line">console.log(a);</span><br><span class="line">&#125;</span><br><span class="line">foo().<span class="keyword">then</span>((res)=&gt;&#123;</span><br><span class="line">console.log(res);</span><br><span class="line">&#125;, catch(e)=&gt;&#123;</span><br><span class="line">consoel.log(e);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;前言：&lt;/strong&gt;&lt;br&gt;时代不断向前，时刻要跟上步伐，要不断保持学习。最新开始做新项目，基于前端工程化用到很多新知识，比如ES6；因此趁机学习补齐短板。&lt;/p&gt;
&lt;h3 id=&quot;let-const定义变量&quot;&gt;&lt;a href=&quot;#let-const定义
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://blog.yuanbeauty.com/categories/JavaScript/"/>
    
      <category term="入门ES6" scheme="http://blog.yuanbeauty.com/categories/JavaScript/%E5%85%A5%E9%97%A8ES6/"/>
    
    
  </entry>
  
  <entry>
    <title>学习VueRouter</title>
    <link href="http://blog.yuanbeauty.com/archives/ab36bed0.html"/>
    <id>http://blog.yuanbeauty.com/archives/ab36bed0.html</id>
    <published>2017-10-22T16:00:00.000Z</published>
    <updated>2017-10-22T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p>Vue官方提供了一个vue-router作为跳转链接组件之间，为何不能使用a标签实现组件跳转链接，以及vue-router怎么使用，怎么实现传参，有哪些需要注意的地方，本篇将开启vue-router的介绍。</p><h3 id="vue-router是什么"><a href="#vue-router是什么" class="headerlink" title="vue-router是什么"></a>vue-router是什么</h3><p>vue-router是路由，这里的路由是SPA(单页面 全称：single page application)路径管理器。</p><p>vue-router是Vue.js官方路由插件，它和Vue.js是深度集成的，用于构建单页面应用。Vue单页面应用是基于路由和组件，路由设定为访问路径，并将路径和组件映射起来。在传统的页面应用中，使用一些超链接实现页面切换跳转；而vue-router单页面应用中，是路径间的切换，也就是组件间的切换。路由模块本质，是建立url和页面之间的映射关系。</p><p>为何不能使用a标签。</p><p>Vue都是单页面应用，在项目打包时，运行npm build就会生成一个dist文件夹，这里面只有静态资源和一个index.html页面，因此必须使用vue-router实现页面跳转。</p><h3 id="vue-router实现原理"><a href="#vue-router实现原理" class="headerlink" title="vue-router实现原理"></a>vue-router实现原理</h3><p>SPA单页面应用，只有一个完整页面；页面在加载时，不会加载整个页面，只是更新某个指定容器里的内容。vue-router实现单页面应用路由，提供两个方式：history模式与hash模式，根据参数mode区分使用哪一种方式。SPA核心是更新视图，不重新请求页面。</p><p>history模式</p><p>配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  mode: &apos;history&apos;,</span><br><span class="line">  routes: [ </span><br><span class="line">    // ... </span><br><span class="line">  ]</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><p>只需要在路由配置项中添加参数mode设置成history即可。</p><p>这种模式和传统url路由看起来没有任何区别，比如：(<a href="http://xxx.com/course/courseId)。" target="_blank" rel="noopener">http://xxx.com/course/courseId)。</a><br>需要注意的是：需要后端配合，使用正确的配置；否则，访问会返回404。大部分情况设置成：如果url输入错误或者匹配不到任何静态资源，就自动跳转到首页。</p><p>histroy模式采用H5 history interface新增的pushState()方法与replaceState()方法；</p><p>这两种方法应用于浏览器记录栈，当前浏览器已有的back/forward/go功能基础上，它们提供了对历史记录修改功能。当它们执行修改时，改变当前url，浏览器不会立即向后端发送请求。</p><p>hash模式</p><p>配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  mode: &apos;hash&apos;,</span><br><span class="line">  routes: [</span><br><span class="line">    // ...</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>只需要在路由配置项中添加参数mode设置成hash即可。</p><p>这种模式和传统url路由看起来有区别，会在url后天添加“ # ”符号后跟一串hash值，<br>比如：<a href="http://xxx.com/course/courseId#hash值。" target="_blank" rel="noopener">http://xxx.com/course/courseId#hash值。</a></p><p>vue-router默认设置成hash模式。使用url的hash模拟一个完整的url，当url发生变化时，页面不会重新加载。“ # ”是页面中的一个位置，是一个锚点；改变后面的hash值，浏览器只会滚动到相应位置，不会重新加载页面。也就是说hash出现在url中，不会被包含在http请求中，对后端完全没有影响，改变url不会重新加载页面。</p><p>每一次改变hash值，都会在浏览器的访问历史中增加一条记录，点击返回按钮，就能回到上一个位置；hash模式是通过不同的锚点值，渲染指定DOM位置的不同数据。hash模式的原理使用onhashchange事件监听hash值的变化，可以在window对象上监听这个事件。</p><h3 id="vue-router使用"><a href="#vue-router使用" class="headerlink" title="vue-router使用"></a>vue-router使用</h3><p>使用Vue官网提供的vue-cli脚手架。</p><p>在src目录下创建一个router文件夹，在该文件夹下创建一个index.js存放路由。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// index.js</span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import VueRouter from &apos;vue-router&apos;</span><br><span class="line">const TeacherCourseList = ()=&gt;import(&apos;@/teacher/course.list&apos;)</span><br><span class="line">const TeacherInfo = ()=&gt;import(&apos;@/teacher/info&apos;)</span><br><span class="line">Vue.use(VueRouter) // 使用use方法注册使用路由</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  mode: &apos;history&apos;,</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">       path: &apos;/teacher/courselist&apos;,</span><br><span class="line">       component: TeacherCourseList,</span><br><span class="line">       // 如果该路由下有 -&gt; 子路由</span><br><span class="line">       // 在该路由下添加children 进行路由嵌套</span><br><span class="line">       children: [</span><br><span class="line">         &#123;</span><br><span class="line">           path: &apos;/teacher/info&apos;,</span><br><span class="line">           component: TeacherInfo</span><br><span class="line">         &#125;</span><br><span class="line">       ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line">export default router</span><br></pre></td></tr></table></figure><p>引入router，注册路由到整个应用都有路由功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// app.js</span><br><span class="line">import router from &apos;@/router&apos;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  // ...</span><br><span class="line">  router // 相当于：router: router，vue官方默认router简写，</span><br><span class="line">        // 如果定义别名 使用router: 路由别名</span><br><span class="line">&#125;).$mount(&apos;#app&apos;);</span><br></pre></td></tr></table></figure><p>模版中使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;router-link to=&quot;/teacher/courselist&quot;&gt; router &lt;/router-link&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>router-view表示路由匹配到的组件在该地方展示。</p><p>vue-router样式选中：</p><ul><li>在配置项中添加linkActiveClass选项。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">new VueRouter(&#123;</span><br><span class="line">  linkActiveClass: &apos;curr&apos;, // 可以自定义class</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>在router-link中写入active-class。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link class=&quot;active-class&quot; to=&quot;/teacher/courselist&quot;&gt; router &lt;/router-link&gt;</span><br></pre></td></tr></table></figure><p>这样书写会出现一个问题，只要以to开头的都会激活选中样式。</p><p>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link to=&quot;/&quot; class=&quot;active-class&quot;&gt; router &lt;/router-link&gt;</span><br><span class="line">&lt;router-link to=&quot;/a&quot; class=&quot;active-class&quot;&gt; router &lt;/router-link&gt;</span><br></pre></td></tr></table></figure><p>可以使用exact属性精确匹配模式解决。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link to=&quot;/&quot; class=&quot;active-class&quot; exact&gt; router &lt;router-link&gt;</span><br></pre></td></tr></table></figure><p>表示这个链接只会在地址为 / 时被激活。</p><p>路由重定向</p><p>也是通过routes配置完成；重定向的目标可以是一个命名的路由；可以是一个方法，动态返回重定向目标。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &apos;/teacher/courselist&apos;,</span><br><span class="line">      redirect: &apos;/courselist&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: &apos;/teacher/courselist&apos;,</span><br><span class="line">      redirect: &#123;</span><br><span class="line">        name: &apos;TeacherCourseList&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: &apos;/teacher/courselist&apos;,</span><br><span class="line">      redirect: to =&gt; &#123;</span><br><span class="line">         // 方法接收 目标路由 作为参数</span><br><span class="line">         // return 重定向的字符串路径/路径对象</span><br><span class="line">         return &apos;/teacher/courselist&apos;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h3><ul><li>使用to</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 定义</span><br><span class="line">routes: [</span><br><span class="line">  &#123;</span><br><span class="line">    name: &apos;teacherPCCourseList&apos;,</span><br><span class="line">    path: &apos;/teacher/courselist/:courseId/teacherId&apos;,</span><br><span class="line">    component: TeacherCourseList</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>可以给路由取个name属性名字，代表当前路由；:courseId表示动态参数，teacherId表示静态参数</p><p>页面传参</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.$router.push(&#123;</span><br><span class="line">    path: `/teacher/courselist/$&#123;courseId&#125;/01`</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>获取参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; this.$route.params.courseId &#125;&#125; </span><br><span class="line">-- </span><br><span class="line">&#123;&#123; this.$route.params.teacherId &#125;&#125;</span><br></pre></td></tr></table></figure><p>特点：<strong>参数拼接在后面，丑陋；而且暴露信息</strong>。</p><ul><li>使用params</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 定义</span><br><span class="line">routes: [</span><br><span class="line">  &#123;</span><br><span class="line">    name: &apos;TeacherPCCourseList&apos;,</span><br><span class="line">    path: &apos;/teacher/courselist&apos;,</span><br><span class="line">    component: TeacherCourseList</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>页面传参</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">this.$router.push(&#123;</span><br><span class="line">    name: &apos;TeacherPCCourseList&apos;,</span><br><span class="line">    params: &#123;</span><br><span class="line">      courseId: courseId </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>获取参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; this.$route.params.courseId &#125;&#125;</span><br></pre></td></tr></table></figure><p>特点：<strong>页面刷新后面参数会丢失</strong>。</p><ul><li>使用query</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 定义</span><br><span class="line">routes: [</span><br><span class="line">  &#123;</span><br><span class="line">    name: &apos;TeacherPCCourseList&apos;,</span><br><span class="line">    path: &apos;/teacher/courselist&apos;,</span><br><span class="line">    query: &#123; </span><br><span class="line">      courseId: courseId</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>页面传参</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">this.$router.push(&#123;</span><br><span class="line">    name: &apos;TeacherPCCourseList&apos;,</span><br><span class="line">    query: &#123;</span><br><span class="line">      courseId: courseId</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>获取参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; this.$route.query.courseId &#125;&#125;</span><br></pre></td></tr></table></figure><p>特点：<strong>不会在后面拼接参数，页面刷新参数不会丢失</strong>。</p><h3 id="route与-router"><a href="#route与-router" class="headerlink" title="$route与$router"></a>$route与$router</h3><p>$route是路由信息对象，包括：path，name，params，query，hash等。</p><p>$route.path：表示当前路由的路径，解析为绝对路径；如：/list。</p><p>$route.name：表示当前路径名称。</p><p>$route.params：表示当前路由参数，是一个key/value对象，包含动态参数和静态参数；没有查询到是一个空对象。</p><p>$route.query：表示当前路由参数，是一个key/value对象，包含动态参数和静态参数；没有查询到是一个空对象。</p><p>$route.hash：表示当前路由的hash值；没有hash值，是个空字符串。</p><p>$router是路由实例对象，使用new VueRouter创建的实例，包括：路由跳转方法，钩子函数等。</p><p>常见的路由跳转方式：</p><p>$router.go(-1)；表示跳转到上一次浏览的页面。</p><p>$router.replace(‘/teacher/couselist’)；表示跳转该指定地址。</p><p>$router.replace({name:’TeacherPCCourseList’ })；使用name属性跳转该指定地址。</p><p>$router.push(‘/teacher/courselist’)；表示跳转该指定地址。</p><p>$router.push({ name: ‘TeacherPCCourseList’ })；使用name属性进行跳转该指定地址。</p><p>$router.replace与$router.push区别：</p><p>使用replace方法不会向浏览器history栈添加新记录，而是替换当前history栈中的记录；当replace跳转到页面后，使用浏览器后退按钮不能查看之前的页面。</p><p>使用push方法会向浏览器history栈添加新记录，使用浏览器后退按钮能查看之前的页面。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Vue官方提供了一个vue-router作为跳转链接组件之间，为何不能使用a标签实现组件跳转链接，以及vue-router怎么使用，怎么实现传参，有哪些需要注意的地方，本篇将开启vue-router的介绍。&lt;/p&gt;
&lt;h
      
    
    </summary>
    
    
      <category term="Vue" scheme="http://blog.yuanbeauty.com/categories/Vue/"/>
    
      <category term="深出浅入vue-router" scheme="http://blog.yuanbeauty.com/categories/Vue/%E6%B7%B1%E5%87%BA%E6%B5%85%E5%85%A5vue-router/"/>
    
    
  </entry>
  
  <entry>
    <title>深入学习Vue响应式原理</title>
    <link href="http://blog.yuanbeauty.com/archives/31d66cf8.html"/>
    <id>http://blog.yuanbeauty.com/archives/31d66cf8.html</id>
    <published>2017-09-22T16:00:00.000Z</published>
    <updated>2017-09-22T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong><br>Vue是参考mvvm模式设计的一套用于构建用户界面的渐进式框架，可以自底向上逐层应用，采用非侵入性的响应式系统。在修改数据时，视图也会跟着更新，开发过程中只需关注数据。</p><h3 id="开发中的响应式："><a href="#开发中的响应式：" class="headerlink" title="开发中的响应式："></a>开发中的响应式：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;p&gt;数量：&#123;&#123; num &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;价格：&#123;&#123; num * price &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;总计：&#123;&#123; total &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button @click=&quot;btn&quot;&gt;点击按钮&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">expprt default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      num: 1,</span><br><span class="line">      price: 2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    total: function() &#123;</span><br><span class="line">      return this.num * this.price;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    btn: function() &#123;</span><br><span class="line">      this.num = 10;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>页面属性num发生变化时，经历了</p><ul><li>获取属性num</li><li>更新属性num值</li><li>计算total值，更新页面<br>数据发生变化后，页面会重新更新数据。</li></ul><p>想要完成整个过程，需要：</p><ul><li>侦测数据变化 (简称：数据劫持)</li><li>收集视图依赖数据 (简称：依赖收集)</li><li>数据变化，通知视图需要更新的部分 (简称：发布订阅模式)</li></ul><h3 id="数据劫持"><a href="#数据劫持" class="headerlink" title="数据劫持"></a>数据劫持</h3><p>Vue2.x版本中使用Object.defineProperty进行数据劫持。</p><p>Vue通过对象属性getter/setter监听数据变化，通过getter进行依赖收集，每个setter方法就是一个观察者，数据发生变化时通知订阅者更新视图。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">var data = &#123;</span><br><span class="line">  title: &apos;Vue&apos;,</span><br><span class="line">  obj: &#123;</span><br><span class="line">    age: 6</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line">function observer(data) &#123;</span><br><span class="line">  if(data &amp;&amp; typeof data == &apos;object&apos;) &#123;</span><br><span class="line">    Object.keys(data).forEach(function(key) &#123;</span><br><span class="line">      defineReactive(data, key, data[key]);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function defineReactive(data, key, value) &#123;</span><br><span class="line">  observer(value); // 劫持每一层数据</span><br><span class="line">  Object.defineProperty(data, key, &#123;</span><br><span class="line">    enumberable: true, // 可枚举</span><br><span class="line">    configurable: true, // 可配置</span><br><span class="line">    get: function() &#123;</span><br><span class="line">      console.log(&apos;get&apos;, value)</span><br><span class="line">      return value;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: function(newVal) &#123;</span><br><span class="line">      console.log(&apos;set&apos;, newVal);</span><br><span class="line">      observer(newVal) // 劫持新值</span><br><span class="line">      if(newVal !== value) &#123; </span><br><span class="line">          value = newVal;      </span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">observer(data);</span><br><span class="line">data.title // get vue</span><br><span class="line">data.obj = &#123;</span><br><span class="line">  age: 60</span><br><span class="line">&#125; // set &#123; age: 60 &#125;</span><br></pre></td></tr></table></figure><p>函数observe传入一个需要被追踪变化的对象data，遍历对象每个属性都使用defineReactive处理，实现侦测对象变化。</p><p>侦测Vue中的data数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Vue(options) &#123;</span><br><span class="line">  this.$el = options.el;</span><br><span class="line">  this.$data = options.data;</span><br><span class="line">  this.$options = options;</span><br><span class="line">  if(this.$el) &#123;</span><br><span class="line">    observer(this.$data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>只需要new Vue一个对象，就会将data中数据进行追踪变化。</p><p>需要注意的是Object.defineProperty有以下缺点：</p><ul><li>无法检测对象属性的添加和删除</li></ul><p>因为Vue通过Object.defineProperty将对象的key转化成getter/setter依赖追踪变化，而getter/setter只能追踪数据是否被修改，却无法追踪新增属性和删除属性。</p><p>对于新增属性，使用Vue.set()方法，可以将新增属性添加到Vue响应式系统中；如：在data对象下新增一个size属性，使用Vue.set(data, ‘size’, ‘10KB’)，参数依次是：目标对象，目标对象新增属性，目标对象新增属性值。</p><p>也可以给这个对象重新赋值，如：Vue.set(data, ‘title’, ‘MVue’) 。</p><p>对于删除属性，使用Vue.delete(目标对象, 删除目标对象属性)；如：Vue.delete(data, ‘obj’)。</p><ul><li>不能监听数组变化，可以对数组方法进行重写(参考深入浅出Vue.js)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;小社区&apos;, &apos;社区&apos;, &apos;大社区&apos;];</span><br><span class="line">// 定义数组方法</span><br><span class="line">var arrMethods = [&apos;push&apos;, &apos;shift&apos;, &apos;pop&apos;, &apos;unshift&apos;];</span><br><span class="line">// 获取数组原型</span><br><span class="line">var arr_proto = Array.prototype;</span><br><span class="line">// 创建新原型对象</span><br><span class="line">var _proto = Object.create(arr_proto); </span><br><span class="line">arrMethods.forEach(function(method) &#123;</span><br><span class="line">  _proto[method] = function() &#123;</span><br><span class="line">      var res = arr_proto[method].call(this, ...arguments);     </span><br><span class="line">      return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">function observer(data) &#123;</span><br><span class="line">  if(Array.isArray(data)) &#123;</span><br><span class="line">      data.__proto__ = _proto;</span><br><span class="line">      return;</span><br><span class="line">  &#125;</span><br><span class="line">  if(data &amp;&amp; typeof data == &apos;object&apos;) &#123;</span><br><span class="line">    Object.keys(data).forEach(function(key) &#123;</span><br><span class="line">      defineReactive(data, key, data[key]);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line">function defineReactive(data, key, value) &#123;</span><br><span class="line">  observer(value);</span><br><span class="line">  Object.defineProperty(data, key, &#123;</span><br><span class="line">    enumberable: true,</span><br><span class="line">    configurable: true,</span><br><span class="line">    get: function() &#123;</span><br><span class="line">      console.log(&apos;get&apos;, value);</span><br><span class="line">      return value;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: function(newVal) &#123;</span><br><span class="line">      console.log(&apos;set&apos;, newVal);</span><br><span class="line">      observer(newVal);</span><br><span class="line">      if(newVal !== value) &#123;</span><br><span class="line">        value = newVal;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">//添加属性重新赋值给新的对象</span><br><span class="line">function $set(data, key, value) &#123;</span><br><span class="line">  defineProperty(data, key, value);</span><br><span class="line">&#125;</span><br><span class="line">observer(arr);</span><br><span class="line">arr.shift(); // 使用定义数组中方法</span><br><span class="line">console.log(obj); // [&quot;社区&quot;, &quot;大社区&quot;]</span><br></pre></td></tr></table></figure><p>上述把数组原自带的方法进行重写，覆盖掉原数组方法；重写后的数组方法需要被拦截，但是Vue对这些重写的方法是拦截不到的，也就不能响应。</p><p>比如：修改上述数组某一项值，无法侦测数组变化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr[1] = &apos;物业&apos;;</span><br></pre></td></tr></table></figure><p>Vue3.x使用proxy作为实现代理，proxy具有代理、拦截与劫持的特征。</p><p>proxy实现特征：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let arr = [&apos;小社区&apos;, &apos;社区&apos;， &apos;大社区&apos;];</span><br><span class="line">let handler = &#123;</span><br><span class="line">  get(data, key) &#123;</span><br><span class="line">    if(typeof data[key] == &apos;object&apos; &amp;&amp; </span><br><span class="line">    data[key] !== null) &#123;</span><br><span class="line">      return new Proxy(data[key], handler);</span><br><span class="line">    &#125;</span><br><span class="line">    return Reflect.get(data, key);</span><br><span class="line">  &#125;,</span><br><span class="line">  set(data, key, value) &#123;</span><br><span class="line">    if(key == &apos;length&apos;) return true;</span><br><span class="line">    return Reflect.set(data, key, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let proxy = new Proxy(arr, handler);</span><br><span class="line">proxy[0] = &apos;物业&apos;;</span><br><span class="line">console.log(proxy); // Proxy &#123;0: &quot;物业&quot;, 1: &quot;社区&quot;, 2: &quot;大社区&quot;&#125;</span><br></pre></td></tr></table></figure><p>对比Object.defineProperty与proxy：</p><p>Object.fefineProperty必须遍历对象每个属性；无法检测对象属性的新增属性与删除属性；无法监听重写数组方法的变化。</p><p>proxy只需做一层代理就能监听同级结构下所有属性，支持代理数组变化。(深层次的数据结构，还是需要递归)</p><h3 id="收集依赖"><a href="#收集依赖" class="headerlink" title="收集依赖"></a>收集依赖</h3><p>观察数据目的是当数据属性发生变化时，可以通知那些使用了该数据的地方。</p><p>比如：开篇用到的数据num，当数据num发生变化时，会通知所有用到数据num的地方。</p><p>如果是多个Vue实例共用一个变量，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;Vue&apos;;</span><br><span class="line">var vm1 = new Vue(&#123;</span><br><span class="line">  data: str,</span><br><span class="line">  template: &apos;&lt;div&gt; &#123;&#123; str &#125;&#125; &lt;/div&gt;&apos;</span><br><span class="line">&#125;)</span><br><span class="line">var vm2 = new Vue(&#123;</span><br><span class="line">  data: str,</span><br><span class="line">  template: &apos;&lt;div&gt; &#123;&#123; str &#125;&#125; &lt;/div&gt;&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>此时更改str属性值，这两个实例视图会更新。那么只有通过收集依赖才能知道哪些地方依赖了数据str，以及数据str派发更新数据。</p><p>收集依赖核心思想是事件发布订阅模式，这里有两个角色：订阅者Dep和观察者Watcher。</p><p>收集依赖是为依赖寻找一个存储依赖的地方，因此创建了Dep。使用订阅者Dep用来收集依赖，删除依赖、向依赖发送消息。</p><p>简单实现订阅者Dep：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Dep() &#123;</span><br><span class="line">  this.subs = []; // 存储Watcher</span><br><span class="line">&#125;</span><br><span class="line">Dep.prototype.addSub = function(sub) &#123;</span><br><span class="line">  this.subs.push(sub); // 添加Watcher</span><br><span class="line">&#125;</span><br><span class="line">Dep.prototype.notify = function() &#123;</span><br><span class="line">  this.subs.forEach(function(sub) &#123;</span><br><span class="line">    sub.update(); // 通知Watcher更新视图</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码订阅者Dep的作用是存储观察者Watcher，可以把观察者Watcher理解成一个中转站，当数据发生变化时通知观察者Watcher，再有观察者Watcher通知其他地方。</p><p>当需要依赖收集时调用函数addSub，当需要派发更新时调用函数notify。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var dep = new Dep();</span><br><span class="line">dep.addSub(function() &#123;</span><br><span class="line">  console.log(&apos;add&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">dep.notify();</span><br></pre></td></tr></table></figure><p>如何收集依赖：在getter中收集依赖，在setter中触发依赖；就是把用到该数据的地方收集起来，等到属性发生变化时，把之前收集好的依赖循环触发一边。</p><p>具体是当外界通过观察者Watcher读取数据时就会触发getter，将观察者Watcher添加到依赖中。哪个观察者Watcher触发getter就把哪个观察者Watcher收集到Dep中；当数据发生变化时，会循环依赖列表，把所有的观察者Watcher都通知一遍。</p><h3 id="观察者Watcher"><a href="#观察者Watcher" class="headerlink" title="观察者Watcher"></a>观察者Watcher</h3><p>Vue官方定义一个Watcher类用来表示观察订阅依赖。其中《深入浅出Vue.js》给出这样的解释：为什么要引入观察者Watcher。</p><p>在属性发生变化后，需要通知用到该数据的地方。而该数据可能被很多地方用到，并且类型还不一样，可能是模版，可能是开发者编写的watch。这时候需要抽象出一个能集中处理这些情况的类，然后在依赖收集阶段只收集这个封装好的类的实例，通知也只通知这个封装好的类的实例，再由这个封装好的类的实例通知到其他。</p><p>依赖收集的目的是将观察者Watcher存放到当前订阅者Dep的subs中。</p><p>简单实现观察者Watcher：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function Watcher(data, key, cb) &#123; // cb -&gt;callback缩写</span><br><span class="line">  Dep.target = this;</span><br><span class="line">  // Dep.target 指向自己，在触发getter时添加监听</span><br><span class="line">  this.data = data;</span><br><span class="line">  this.key = key;</span><br><span class="line">  this.cb = cb;</span><br><span class="line">  this.value = data[key];</span><br><span class="line">  Dep.target = null; </span><br><span class="line">  // 如果不为null，每次都追加一个Dep</span><br><span class="line">  // 比如：第一次是[&apos;Dep&apos;], 第二次是[&apos;Dep&apos;, &apos;Dep&apos;], ...</span><br><span class="line">&#125;</span><br><span class="line">Watcher.prototype.update = function() &#123;</span><br><span class="line">  this.value = this.data[this.key];</span><br><span class="line">  this.cb(this.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行构造函数把Dep.target指向自身，收集到对应的Watcher，在派发更新时取出对应的观察者Watcher，执行函数update。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>结合以上内容实现一个简单响应式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var data = &#123;</span><br><span class="line">  title: &apos;vue&apos;,</span><br><span class="line">  obj: &#123;</span><br><span class="line">    age: 6</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">function Dep() &#123;</span><br><span class="line">  this.subs = [];</span><br><span class="line">&#125;</span><br><span class="line">Dep.prototype.addSub = function(sub) &#123;</span><br><span class="line">  this.subs.push(sub);</span><br><span class="line">&#125;</span><br><span class="line">Dep.prototype.notify = function() &#123;</span><br><span class="line">  console.log(&apos;Dep notify&apos;);</span><br><span class="line">  // this.subs.forEach(function(sub) &#123;</span><br><span class="line">  // sub.update()</span><br><span class="line">  // &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function render() &#123;</span><br><span class="line">  console.log(&apos;模版render...&apos;);</span><br><span class="line">&#125;</span><br><span class="line">function observer(data) &#123;</span><br><span class="line">  if(data &amp;&amp; typeof data == &apos;object&apos;) &#123;</span><br><span class="line">    Object.keys(data).forEach(function(key) &#123;</span><br><span class="line">      defineReactive(data, key, data[key]);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">function defineReactive(data, key, value) &#123;</span><br><span class="line">  observer(value);</span><br><span class="line">  var dep = new Dep();</span><br><span class="line">  Object.defineProperty(data, key, &#123;</span><br><span class="line">    enumberable: true,</span><br><span class="line">    configurable: true,</span><br><span class="line">    get: function() &#123;</span><br><span class="line">      console.log(&apos;get：&apos; value);</span><br><span class="line">      Dep.target &amp;&amp; dep.addSub(Dep.target);</span><br><span class="line">      return value;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: function (newVal) &#123;</span><br><span class="line">      console.log(&apos;set：&apos;, newVal);</span><br><span class="line">      if(newVal !== value) &#123;</span><br><span class="line">        value = newVal;</span><br><span class="line">        dep.notify();</span><br><span class="line">        render();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function MVue(options) &#123;</span><br><span class="line">  this.$options = options;</span><br><span class="line">  this.$el = options.el;</span><br><span class="line">  this.$data = options.data;</span><br><span class="line">  if(this.$el) observer(this.$data);</span><br><span class="line">&#125;</span><br><span class="line">new MVue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  data: data</span><br><span class="line">&#125;)</span><br><span class="line">data.title; // 首次访问数据</span><br><span class="line">data.title = &apos;MVue&apos;; // 修改数据</span><br><span class="line">data.title; // 访问修改后的数据</span><br></pre></td></tr></table></figure><p>函数render被渲染时，读取所需对象的值，会触发getter方法把当前观察者Watcher收集到函数Dep中；如果需要修改对象的值，会触发setter方法，通知函数Dep中的notify方法，触发所有观察者Watcher对象中的update方法更新对应视图。</p><p>总结Vue响应式原理</p><p>通过数据劫持结合订阅与发布者模式的方式，通过Object.defineProperty劫持各个属性的getter/setter，在数据发生变化时发布消息给订阅者，触发相应的回调函数。</p><p>执行new Vue整个过程发生了：</p><p>new Vue后，Vue会调用函数_init进行初始化。在这个过程data通过函数observer转化成getter/setter追踪数据变化；当被设置的对象被读取时会执行getter方法，当对象被重新赋值时会执行setter方法。</p><p>函数render执行时，会读取所需对象的值，会触发getter方法把观察者Watcher添加到依赖中进行依赖收集。</p><p>修改对象的值时，会触发相应的setter方法；setter方法通知之前依赖收集得到的Dep中每一个观察者Watcher，再有观察者Watcher通知其他，自己的值被更改了需要重新渲染视图；这时观察者Watcher就会调用update方法更新视图。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;br&gt;Vue是参考mvvm模式设计的一套用于构建用户界面的渐进式框架，可以自底向上逐层应用，采用非侵入性的响应式系统。在修改数据时，视图也会跟着更新，开发过程中只需关注数据。&lt;/p&gt;
&lt;h3 id=&quot;开发中的响应式：&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="Vue" scheme="http://blog.yuanbeauty.com/categories/Vue/"/>
    
      <category term="深入浅出Vue响应式" scheme="http://blog.yuanbeauty.com/categories/Vue/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAVue%E5%93%8D%E5%BA%94%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>模拟Form表单完成数据交互</title>
    <link href="http://blog.yuanbeauty.com/archives/f536e456.html"/>
    <id>http://blog.yuanbeauty.com/archives/f536e456.html</id>
    <published>2017-06-11T16:00:00.000Z</published>
    <updated>2017-06-11T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言：</strong></p><p>之前和后端配合完成数据交互时，只需要拿到后端API进行POST/GET就可以完成数据交互。最近开发老项目，遇到一个需求：</p><p>在当前页面选择需要结算的课程<strong>可以选多个课程</strong>，点击下一步，不请求后端API，跳到下个页面；对于这个数据交互需要兼容性一开始没想起来解决办法。后面大伙讨论使用form特征解决。</p><p><strong>方案：</strong></p><ul><li>如果不考虑兼容性问题，可以使用浏览器存储localStorage/sessionStorage方式解决。</li><li>如果考虑兼容性使用form来模拟表单方式提交数据，完成页面跳转。</li></ul><p><strong>用法：</strong></p><ul><li>使用浏览器存储解决<br>在当前页面选择多个课程时，把数据存储到浏览器存储中，跳转到下个页面取出浏览器存储中的数据。</li></ul><p>存储数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var courseList = [...]</span><br><span class="line"></span><br><span class="line">localStorage.setItem(&apos;courseList&apos;, courseList);</span><br></pre></td></tr></table></figure></p><p>取出数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var localCourseList = localStorage.getItem(&apos;courseList&apos;);</span><br></pre></td></tr></table></figure></p><ul><li>使用form表单方式</li></ul><p>使用jQuery中的extends方法扩展一个POST方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$.extend(&#123;</span><br><span class="line">StandardPost:function(url, args)&#123;</span><br><span class="line">var form = $(&quot;&lt;form method=&apos;post&apos; style=&apos;display:none&apos;&gt;&lt;/form&gt;&quot;), input;</span><br><span class="line">form.attr(&#123; &quot;action&quot;:url &#125;);</span><br><span class="line">args=JSON.parse(args);</span><br><span class="line">$.each(args, function(key2, value2) &#123;</span><br><span class="line">$.each(value2,function(key, value)&#123;</span><br><span class="line">input = $(&quot;&lt;input type=&apos;hidden&apos;&gt;&quot;);</span><br><span class="line">input.attr(&#123; &quot;name&quot;:&apos;objectArray[&apos;+key2+&apos;][&apos;+key+&apos;]&apos;&#125;);</span><br><span class="line">input.val(value);</span><br><span class="line">form.append(input);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">form.appendTo($(&apos;body&apos;));</span><br><span class="line">form.submit();</span><br><span class="line">form.remove();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$.post(url, &#123; data:data &#125;, function(r) &#123;</span><br><span class="line">if(r.code==0) &#123;</span><br><span class="line">// 传入url 和 data</span><br><span class="line">//url 是要跳转到下个界面的路径</span><br><span class="line">$.StandardPost(url, data); </span><br><span class="line">&#125;</span><br><span class="line">&#125;, &apos;json&apos;);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;前言：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;之前和后端配合完成数据交互时，只需要拿到后端API进行POST/GET就可以完成数据交互。最近开发老项目，遇到一个需求：&lt;/p&gt;
&lt;p&gt;在当前页面选择需要结算的课程&lt;strong&gt;可以选多个课程&lt;/strong&gt;，点击
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://blog.yuanbeauty.com/categories/JavaScript/"/>
    
      <category term="模拟form表单" scheme="http://blog.yuanbeauty.com/categories/JavaScript/%E6%A8%A1%E6%8B%9Fform%E8%A1%A8%E5%8D%95/"/>
    
    
  </entry>
  
  <entry>
    <title>回调函数</title>
    <link href="http://blog.yuanbeauty.com/archives/a03e68d3.html"/>
    <id>http://blog.yuanbeauty.com/archives/a03e68d3.html</id>
    <published>2016-08-02T16:00:00.000Z</published>
    <updated>2016-08-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p>最近一直忙于项目，没时间总写，趁现在有时间总结下遇到的问题。</p><h3 id="data-书写"><a href="#data-书写" class="headerlink" title="data-*书写"></a><code>data-*</code>书写</h3><p>处理数据交互，有时候需要在一些元素上绑定一些<code>data-*</code>数据，不经意间有可能在JS中写成大写的，比如：<code>data-Id</code>，但是在<code>html</code>解析时，浏览器解析的是小写<code>data-id</code>，在调试JS数据交互，有可能很纳闷，明明绑定上去数据，为何获取不到。</p><p>因此建议在书写时，写成小写的，避免坑了自己，比如：<code>data-id</code></p><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>之前项目很少遇到ajax回调，估计项目复杂度不够，应用不到吧；还有就是本身知识有短板。查了很多资料找到了ajax回调函数例子。</p><p>原理：</p><ul><li><p>在函数中传一个参数，如：callBack。</p></li><li><p>在函数体中，把传入的参数callBack当成一个函数，把需要获的数据传入callback这个函数。</p></li></ul><p>用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function fn(callBack) &#123;</span><br><span class="line">$.post(xxx, &#123; xxx &#125;, function(r) &#123;</span><br><span class="line">callBack(r);</span><br><span class="line">&#125;, &apos;json&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最近一直忙于项目，没时间总写，趁现在有时间总结下遇到的问题。&lt;/p&gt;
&lt;h3 id=&quot;data-书写&quot;&gt;&lt;a href=&quot;#data-书写&quot; class=&quot;headerlink&quot; title=&quot;data-*书写&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://blog.yuanbeauty.com/categories/JavaScript/"/>
    
      <category term="JS回调函数" scheme="http://blog.yuanbeauty.com/categories/JavaScript/JS%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript常用算法</title>
    <link href="http://blog.yuanbeauty.com/archives/73d2d809.html"/>
    <id>http://blog.yuanbeauty.com/archives/73d2d809.html</id>
    <published>2016-06-05T16:00:00.000Z</published>
    <updated>2016-06-05T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>前言</p><p>本篇基本算法针对常用方法，无论在任何地方都有可能使用到。在这里做下笔记，偶尔拿来看看。^-^</p><h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><ul><li><p>利用对象属性不可重复特征</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function sort(arr) &#123;</span><br><span class="line">  var obj = &#123;&#125;;</span><br><span class="line">  var newArr = [];</span><br><span class="line">  for(var i=0; i&lt;arr.length; i++) &#123;</span><br><span class="line">    if(!obj[arr[i]]) &#123;</span><br><span class="line">      newArr.push(arr[i]);</span><br><span class="line">      obj[arr[i]] = 1; // 随意赋值</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return newArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>利用数组splice方法</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function sort(arr) &#123;</span><br><span class="line">  for(var i=0; i&lt;arr.length; i++) &#123;</span><br><span class="line">    for(var j=i+1; j&lt;arr.length; j++) &#123;</span><br><span class="line">      if(arrr[i] == arr[j]) &#123;</span><br><span class="line">        arr.splice(j, 1)</span><br><span class="line">        j--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>利用数组indexOf方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function sort(arr) &#123;</span><br><span class="line">  var newArr = [];</span><br><span class="line">  for(var i=0; i&lt;arr.length; i++) &#123;</span><br><span class="line">    if(newArr.indexOf(arr[i]) == -1) &#123;</span><br><span class="line">      newArr.push(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return newArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function sort(arr) &#123;</span><br><span class="line">  var newArr = [];</span><br><span class="line">  for(var i=0; i&lt;arr.length; i++) &#123;</span><br><span class="line">    if(arr.indexOf(arr[i]) == i) &#123;</span><br><span class="line">      newArr.push(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return newArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用ES6特征</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[... new Set([1, 1, 2, 2])]</span><br><span class="line">// or</span><br><span class="line">Array.from(new Set([1, 1, 2, 2]))</span><br></pre></td></tr></table></figure><h3 id="闭包运用"><a href="#闭包运用" class="headerlink" title="闭包运用"></a>闭包运用</h3><p>输入sum(1)(2)与sum(1, 2)值相等<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function sum() &#123;</span><br><span class="line">  var x = arguments[0];</span><br><span class="line">  if(arguments.length == 1) &#123;</span><br><span class="line">    return function(y) &#123;</span><br><span class="line">      return x + y;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    var x = 0;</span><br><span class="line">    for(var i=0; i&lt;arguments.length; i++) &#123;</span><br><span class="line">      x = x + arguments[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序是最简单的排序算法。它重复走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，即该数列已经排序完成。<br>思路：</p><ul><li>比较相邻的元素，如果第一个比第二个大，就交换它们。</li><li>对每一个相邻元素做同样的工作，从开始第一对到结尾的最后一对，这一轮结束在最后的元素应该会是最大的数。</li><li>对所有的元素重复以上步骤，除了最后一个。</li><li>重复以上步骤，直到排序完成。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function sort(arr) &#123;</span><br><span class="line">  var temp = &apos;&apos;;</span><br><span class="line">  if(arr.length &lt;= 1) return arr;</span><br><span class="line">  for(var i=0; i&lt;arr.length-1; i++) &#123;</span><br><span class="line">    for(var j=0; j&lt;arr.length-1-i; j++) &#123;</span><br><span class="line">      if(arr[j] &gt; arr[j+1]) &#123;</span><br><span class="line">        temp = arr[j+1];</span><br><span class="line">        arr[j+1] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>冒泡排序特征：如果数据足够大运行效率低，也比较耗时。</p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>基本思想：通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分关键字小，则可分别对这两部分记录继续进行排序，达到整个序列有序。</p><p>思路：</p><ul><li>从数列中找出一个基准元素。</li><li>重新排序数列，所有元素比基准元素小的排在基准元素前面，所有元素比基准元素大的排在基准元素后面(相同的数可以到任意一边)，该基准元素就处于数列的中间位置。</li><li>递归的把小于基准元素的子数列和大于基准元素的子数列排序。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function sort(arr) &#123;</span><br><span class="line">  if(arr.length &lt;= 1) return arr;</span><br><span class="line">  var minIndex = Math.floor(arr.length/2);</span><br><span class="line">  var minVal = arr.splice(minIndex, 1);</span><br><span class="line">  var left = [];</span><br><span class="line">  var right = [];</span><br><span class="line">  for(var i=0; i&lt;arr.length; i++) &#123;</span><br><span class="line">    if(arr[i] &lt; minVal) &#123;</span><br><span class="line">      left.push(arr[i])</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      right.push(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return sort(left).concat(minVal, sort(right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>快速排序特征：声明两个数组，占用内存</p><h3 id="查找字符串重复数"><a href="#查找字符串重复数" class="headerlink" title="查找字符串重复数"></a>查找字符串重复数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function filter(str) &#123;</span><br><span class="line">  var obj = &#123;&#125;;</span><br><span class="line">  return (function() &#123;</span><br><span class="line">    for(var i=0; i&lt;str.length; i++) &#123;</span><br><span class="line">      var val = str.charAt(i);</span><br><span class="line">      if(obj[val] &amp;&amp; obj[val].value == val) &#123;</span><br><span class="line">        obj[val].count = ++obj[val].count;</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        obj[val] = &#123;&#125;;</span><br><span class="line">        obj[val].count = 1;</span><br><span class="line">        obj[val].value = val;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return obj;</span><br><span class="line">  &#125;)()</span><br><span class="line">&#125;</span><br><span class="line">// var str = &apos;aabccddd&apos;;</span><br></pre></td></tr></table></figure><h3 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h3><p>需要计算n的阶乘，最多需要保存n个调用记录，复杂度O(n)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function factorial(x) &#123;</span><br><span class="line">  if(x === 1) return 1;</span><br><span class="line">   return x * fectorial(x - 1);</span><br><span class="line">&#125;</span><br><span class="line">factorial(3) // 6</span><br></pre></td></tr></table></figure></p><p>改写成尾递归(ES6函数尾调用优化部分)<br>只保留一个调用记录，复杂度O(1)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function factorial(x, total) &#123;</span><br><span class="line">  if(x === 1) return total;</span><br><span class="line">  return factorial(x-1, x * total);</span><br><span class="line">&#125;</span><br><span class="line">factorial(3, 1) // 6</span><br></pre></td></tr></table></figure></p><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p>非递归实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function fibonacci(x) &#123;</span><br><span class="line">   if(x &lt;= 1) return 1;</span><br><span class="line">    return fibonacci(x - 1) + fibonacci(x - 2);</span><br><span class="line">&#125;</span><br><span class="line">fibonacci(3) // 3</span><br></pre></td></tr></table></figure></p><p>改写成尾递归(ES6函数尾调用优化部分)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function fibonacci(x, y=1, z=1) &#123;</span><br><span class="line">  if(x &lt;= 1) return z;</span><br><span class="line">  return fibonacci(x-1, z, y+z);</span><br><span class="line">&#125;</span><br><span class="line">fibonacci(3) // 3</span><br></pre></td></tr></table></figure></p><h3 id="字符串可以相减"><a href="#字符串可以相减" class="headerlink" title="字符串可以相减"></a>字符串可以相减</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var start = &apos;2018-07-10 10:30:33&apos;;</span><br><span class="line">var end = &apos;2018-07-10 18:50:45&apos;;</span><br><span class="line">function testTime(start, end) &#123;</span><br><span class="line">  var now = new Date();</span><br><span class="line">  start = new Date(start.replace(/-/g, &apos;-&apos;));</span><br><span class="line">  end = new Date(end.replace(/-/g, &apos;-&apos;));</span><br><span class="line">  if(start - now &gt; 0 &amp;&amp; now - end &lt; 0) &#123;</span><br><span class="line">    return &apos;before&apos;;</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    return &apos;after&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前言&lt;/p&gt;
&lt;p&gt;本篇基本算法针对常用方法，无论在任何地方都有可能使用到。在这里做下笔记，偶尔拿来看看。^-^&lt;/p&gt;
&lt;h3 id=&quot;数组去重&quot;&gt;&lt;a href=&quot;#数组去重&quot; class=&quot;headerlink&quot; title=&quot;数组去重&quot;&gt;&lt;/a&gt;数组去重&lt;/h3&gt;&lt;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://blog.yuanbeauty.com/categories/JavaScript/"/>
    
      <category term="常见JS算法" scheme="http://blog.yuanbeauty.com/categories/JavaScript/%E5%B8%B8%E8%A7%81JS%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Template模板Mustache.js</title>
    <link href="http://blog.yuanbeauty.com/archives/3f14c0ad.html"/>
    <id>http://blog.yuanbeauty.com/archives/3f14c0ad.html</id>
    <published>2016-03-09T16:00:00.000Z</published>
    <updated>2016-03-09T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近项目一直在使用Mustache.js前端模版，那么使用过程中一些语法顺便聊下。</p><h3 id="Mustache简介"><a href="#Mustache简介" class="headerlink" title="Mustache简介"></a>Mustache简介</h3><p>Mustache 是一个 logic-less （轻逻辑）模板解析引擎，它的优势在于可以应用在 Javascript、PHP、Python、Perl 等多种编程语言中。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;keyName&#125;&#125;</span><br><span class="line">&#123;&#123;<span class="comment">#keyName&#125;&#125; &#123;&#123;/keyName&#125;&#125;</span></span><br><span class="line">&#123;&#123;^keyName&#125;&#125; &#123;&#123;/keyName&#125;&#125;</span><br><span class="line">&#123;&#123;.&#125;&#125;</span><br><span class="line">&#123;&#123;&lt;partials&#125;&#125;</span><br><span class="line">&#123;&#123;&#123;keyName&#125;&#125;&#125;</span><br><span class="line">&#123;&#123;!comments&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="Mustache用法"><a href="#Mustache用法" class="headerlink" title="Mustache用法"></a>Mustache用法</h3><p>可以直接下载引用或者npm安装使用；这里使用引用介绍：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"mustache.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">var data = &#123;</span><br><span class="line">  name: <span class="string">"Joe"</span>,</span><br><span class="line">  age:28</span><br><span class="line">&#125;;</span><br><span class="line">var tpl = <span class="string">'&lt;div&gt;My Name：&#123;&#123;Name&#125;&#125;，Age：&#123;&#123;age&#125;&#125;&lt;/div&gt;'</span>;</span><br><span class="line">var html = Mustache.render(tpl, data); //后面省略渲染步骤直接输出结果集</span><br><span class="line">console.log(html); //My Name：Joe，Age：28;</span><br></pre></td></tr></table></figure></p><p>其中花括号就是Mustache标识符号，花括号中的名字表示键名;</p><h3 id="Mustache循环语句"><a href="#Mustache循环语句" class="headerlink" title="Mustache循环语句"></a>Mustache循环语句</h3><p>以#开始、以/结束表示区块，它会根据当前上下文中的键值来对区块进行一次或多次渲染，例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var data = &#123;</span><br><span class="line">  <span class="string">"stooges"</span>: [</span><br><span class="line">    &#123; <span class="string">"name"</span>: <span class="string">"Moe"</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"name"</span>: <span class="string">"Larry"</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"name"</span>: <span class="string">"Curly"</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Template"><a href="#Template" class="headerlink" title="Template:"></a>Template:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;<span class="comment">#stooges&#125;&#125;</span></span><br><span class="line">&lt;b&gt;&#123;&#123;name&#125;&#125;&lt;/b&gt;</span><br><span class="line">&#123;&#123;/stooges&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="输入结果："><a href="#输入结果：" class="headerlink" title="输入结果："></a>输入结果：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;b&gt;Moe&lt;/b&gt;</span><br><span class="line">&lt;b&gt;Larry&lt;/b&gt;</span><br><span class="line">&lt;b&gt;Curly&lt;/b&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//&#123;&#123;^keyName&#125;&#125; &#123;&#123;/keyName&#125;&#125;</span><br><span class="line">//该语法与&#123;&#123;<span class="comment">#keyName&#125;&#125; &#123;&#123;/keyName&#125;&#125;类似，不同在于它是当 keyName 值为 null, undefined, false 时才渲染输出该区块内容。</span></span><br><span class="line">var tpl = &#123;&#123;^nothing&#125;&#125;没找到 nothing 键名就会渲染这段&#123;&#123;/nothing&#125;&#125;;</span><br><span class="line">var html = Mustache.render(tpl, data);</span><br><span class="line">//输出：</span><br><span class="line">没找到 nothing 键名就会渲染这段</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//&#123;&#123;.&#125;&#125;语法 表示枚举；可以循环输出整个数组，例如：</span><br><span class="line">var data = &#123;</span><br><span class="line">  <span class="string">"musketeers"</span>: [<span class="string">"Athos"</span>, <span class="string">"Aramis"</span>, <span class="string">"Porthos"</span>, <span class="string">"D'Artagnan"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Template-1"><a href="#Template-1" class="headerlink" title="Template:"></a>Template:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;<span class="comment">#musketeers&#125;&#125;</span></span><br><span class="line"> &#123;&#123;.&#125;&#125;</span><br><span class="line">&#123;&#123;/musketeers&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="输入结果：-1"><a href="#输入结果：-1" class="headerlink" title="输入结果："></a>输入结果：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Athos</span><br><span class="line">Aramis</span><br><span class="line">Porthos</span><br><span class="line">D<span class="string">'Artagnan</span></span><br></pre></td></tr></table></figure><h3 id="函数节变量"><a href="#函数节变量" class="headerlink" title="函数节变量"></a>函数节变量</h3><p>如果节变量的值是一个函数，它将在每次迭代的列表中的当前项的上下文中调用，例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var data = &#123;</span><br><span class="line">  <span class="string">"beatles"</span>: [</span><br><span class="line">    &#123; <span class="string">"firstName"</span>: <span class="string">"John"</span>, <span class="string">"lastName"</span>: <span class="string">"Lennon"</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"firstName"</span>: <span class="string">"Paul"</span>, <span class="string">"lastName"</span>: <span class="string">"McCartney"</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"firstName"</span>: <span class="string">"George"</span>, <span class="string">"lastName"</span>: <span class="string">"Harrison"</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"firstName"</span>: <span class="string">"Ringo"</span>, <span class="string">"lastName"</span>: <span class="string">"Starr"</span> &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"name"</span>: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    <span class="built_in">return</span> this.firstName + <span class="string">" "</span> + this.lastName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Template-2"><a href="#Template-2" class="headerlink" title="Template:"></a>Template:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;<span class="comment">#beatles&#125;&#125;</span></span><br><span class="line">* &#123;&#123;name&#125;&#125;</span><br><span class="line">&#123;&#123;/beatles&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="输入结果：-2"><a href="#输入结果：-2" class="headerlink" title="输入结果："></a>输入结果：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* John Lennon</span><br><span class="line">* Paul McCartney</span><br><span class="line">* George Harrison</span><br><span class="line">* Ringo Starr</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>如果一个节键的值是一个函数，它被称为节的文本块，未渲染，作为它的第一个参数。第二个参数是一个特殊的渲染函数，它使用当前视图作为视图参数。它在当前视图对象的上下文中调用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var data = &#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"Tater"</span>,</span><br><span class="line">  <span class="string">"bold"</span>: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="keyword">function</span> (text, render) &#123;</span><br><span class="line">      <span class="built_in">return</span> <span class="string">"&lt;b&gt;"</span> + render(text) + <span class="string">"&lt;/b&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Template-3"><a href="#Template-3" class="headerlink" title="Template:"></a>Template:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;<span class="comment">#bold&#125;&#125;Hi &#123;&#123;name&#125;&#125;.&#123;&#123;/bold&#125;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="输入结果：-3"><a href="#输入结果：-3" class="headerlink" title="输入结果："></a>输入结果：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;b&gt;Hi Tater.&lt;/b&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//倒置部分^ &#123;&#123;&#125;&#125; &#123;&#123;部分代替<span class="comment">#节&#125;&#125;</span></span><br><span class="line">//一个倒置的节块呈现只有这部分标签的值为空，不确定的，虚假的，falsy或空列表。</span><br><span class="line">var data = &#123;</span><br><span class="line">  <span class="string">"repos"</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Template-4"><a href="#Template-4" class="headerlink" title="Template:"></a>Template:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;<span class="comment">#repos&#125;&#125;&lt;b&gt;&#123;&#123;name&#125;&#125;&lt;/b&gt;&#123;&#123;/repos&#125;&#125;</span></span><br><span class="line">&#123;&#123;^repos&#125;&#125;No repos :(&#123;&#123;/repos&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="输入结果：-4"><a href="#输入结果：-4" class="headerlink" title="输入结果："></a>输入结果：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No repos :(</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//&#123;&#123;&gt;partials&#125;&#125;语法；</span><br><span class="line">//以&gt;开始表示子模块；当结构比较复杂时，我们可以使用该语法将复杂的结构拆分成几个小的子模块，例如：</span><br><span class="line">var data = &#123;</span><br><span class="line">    <span class="string">"company"</span>: <span class="string">"Apple"</span>,</span><br><span class="line">    <span class="string">"address"</span>: &#123;</span><br><span class="line">        <span class="string">"street"</span>: <span class="string">"1 Infinite Loop Cupertino&lt;/br&gt;"</span>,</span><br><span class="line">        <span class="string">"city"</span>: <span class="string">"California "</span>,</span><br><span class="line">        <span class="string">"state"</span>: <span class="string">"CA "</span>,</span><br><span class="line">        <span class="string">"zip"</span>: <span class="string">"95014 "</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"product"</span>: [<span class="string">"Macbook "</span>,<span class="string">"iPhone "</span>,<span class="string">"iPod "</span>,<span class="string">"iPad "</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Template-5"><a href="#Template-5" class="headerlink" title="Template:"></a>Template:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var tpl = <span class="string">"&lt;h1&gt;&#123;&#123;company&#125;&#125;&lt;/h1&gt; &lt;ul&gt;&#123;&#123;&gt;address&#125;&#125;&lt;/ul&gt;"</span></span><br><span class="line">var partials = &#123;address: <span class="string">"&#123;&#123;#address&#125;&#125;&lt;li&gt;&#123;&#123;street&#125;&#125;&lt;/li&gt;&lt;li&gt;&#123;&#123;city&#125;&#125;&lt;/li&gt;&lt;li&gt;&#123;&#123;state&#125;&#125;&lt;/li&gt;&lt;li&gt;&#123;&#123;zip&#125;&#125;&lt;/li&gt;&#123;&#123;/address&#125;&#125;"</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="输入结果：-5"><a href="#输入结果：-5" class="headerlink" title="输入结果："></a>输入结果：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;Apple&lt;/h1&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;1 Infinite Loop Cupertino&amp;lt;/br&amp;gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;California&lt;/li&gt;</span><br><span class="line">&lt;li&gt;CA&lt;/li&gt;</span><br><span class="line">&lt;li&gt;95014&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//&#123;&#123;&#123;keyName&#125;&#125;&#125; 语法</span><br><span class="line">//输出会将等特殊字符转译，如果想保持内容原样输出可以使用花括号，例如：</span><br><span class="line">var data = &#123;</span><br><span class="line">    <span class="string">"company"</span>: <span class="string">"Apple"</span>,</span><br><span class="line">    <span class="string">"address"</span>: &#123;</span><br><span class="line">        <span class="string">"street"</span>: <span class="string">"1 Infinite Loop Cupertino&lt;/br&gt;"</span>,</span><br><span class="line">        <span class="string">"city"</span>: <span class="string">"California "</span>,</span><br><span class="line">        <span class="string">"state"</span>: <span class="string">"CA "</span>,</span><br><span class="line">        <span class="string">"zip"</span>: <span class="string">"95014 "</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"product"</span>: [<span class="string">"Macbook "</span>,<span class="string">"iPhone "</span>,<span class="string">"iPod "</span>,<span class="string">"iPad "</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Template-6"><a href="#Template-6" class="headerlink" title="Template:"></a>Template:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var tpl = <span class="string">'&#123;&#123;#address&#125;&#125; &lt;p&gt;&#123;&#123;&#123;street&#125;&#125;&#125;&lt;/p&gt; &#123;&#123;/address&#125;&#125;'</span></span><br></pre></td></tr></table></figure><h3 id="输入结果：-6"><a href="#输入结果：-6" class="headerlink" title="输入结果："></a>输入结果：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;1 Infinite Loop Cupertino&lt;/br&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//&#123;&#123;!comments&#125;&#125;语法</span><br><span class="line">表示注释，注释后不会渲染输出任何内容。</span><br><span class="line">``` bash</span><br><span class="line">&#123;&#123;!这里是注释&#125;&#125;</span><br><span class="line">//输出：</span><br></pre></td></tr></table></figure><p>参考文章<br><a href="https://github.com/janl/mustache.js" target="_blank" rel="noopener">https://github.com/janl/mustache.js</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近项目一直在使用Mustache.js前端模版，那么使用过程中一些语法顺便聊下。&lt;/p&gt;
&lt;h3 id=&quot;Mustache简介&quot;&gt;&lt;a href=&quot;#Mustache简介&quot; class=&quot;headerlink&quot; title=&quot;Mustache简介&quot;&gt;&lt;/a&gt;Mustach
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://blog.yuanbeauty.com/categories/JavaScript/"/>
    
      <category term="入门Mustache.js模版引擎" scheme="http://blog.yuanbeauty.com/categories/JavaScript/%E5%85%A5%E9%97%A8Mustache-js%E6%A8%A1%E7%89%88%E5%BC%95%E6%93%8E/"/>
    
    
  </entry>
  
</feed>
